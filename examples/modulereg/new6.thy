theory new6
imports 
Main 

begin 
typedecl PERSON 
typedecl MODULE

record ModuleReg = 
STUDENTS :: " PERSON set"
DEGMODULES :: " MODULE set"
TAKING :: "(PERSON * MODULE) set"

locale Themodulereg = 
fixes students :: " PERSON set"
and degModules :: " MODULE set"
and taking :: "(PERSON * MODULE) set"
assumes "Domain taking \<subseteq> students" 
 and "Range taking \<subseteq> degModules"
begin

definition RegForModule :: 
"ModuleReg \<Rightarrow> ModuleReg \<Rightarrow> PERSON \<Rightarrow> MODULE => MODULE set \<Rightarrow> PERSON set \<Rightarrow> (PERSON * MODULE) set \<Rightarrow> bool"
where 
"RegForModule modulereg modulereg' p m degModules' students' taking' ==
(p \<in> students) 
\<and> (m \<in> degModules) 
\<and> ((p, m) \<notin> taking)
\<and> (taking' = taking \<union> {(p, m)}) 
\<and> (students' = students) 
\<and> (degModules' = degModules)"

definition AddStudent :: 
"ModuleReg \<Rightarrow> ModuleReg => PERSON \<Rightarrow>  MODULE set \<Rightarrow> PERSON set \<Rightarrow> (PERSON * MODULE) set \<Rightarrow> bool"
where 
"AddStudent modulereg modulereg' p degModules' students' taking' ==
 (
(p \<notin> students)
\<and> (students' = students \<union> {(p)}) 
\<and> (degModules' = degModules) 
\<and> (taking' = taking))"

(*The proof obligations generated by ZMathLang start here*)

lemma RegForModule_L1:
"(\<exists> degModules:: MODULE set.
\<exists> students :: PERSON set.
\<exists> taking :: (PERSON * MODULE) set.
\<exists> p :: PERSON.
\<exists> degModules':: MODULE set.
\<exists> students' :: PERSON set.
\<exists> taking' :: (PERSON * MODULE) set.
\<exists> m :: MODULE.
(
(p \<in> students) 
\<and> (m \<in> degModules) 
\<and> ((p, m) \<notin> taking)
\<and> (taking' = taking \<union> {(p, m)}) 
\<and> (students' = students) 
\<and> (degModules' = degModules))
\<and> (Domain taking \<subseteq> students)
\<and> (Range taking \<subseteq> degModules)
\<and> (Domain taking' \<subseteq> students')
\<and> (Range taking' \<subseteq> degModules')
)"
by (smt Domain_empty Domain_insert Range.intros Range_empty 
Range_insert Un_empty Un_insert_right empty_iff empty_subsetI 
empty_subsetI insert_mono insert_mono singletonI singletonI 
singleton_insert_inj_eq' singleton_insert_inj_eq')

lemma AddStudent_L2:
"(\<exists> degModules:: MODULE set.
\<exists> students :: PERSON set.
\<exists> taking :: (PERSON * MODULE) set.
\<exists> p :: PERSON.
\<exists> degModules':: MODULE set.
\<exists> students' :: PERSON set.
\<exists> taking' :: (PERSON * MODULE) set.
 (
 (students' = students \<union> {(p)}) 
\<and> (degModules' = degModules) 
\<and> (taking' = taking))
\<and> (Domain taking \<subseteq> students)
\<and> (Range taking \<subseteq> degModules)
\<and> (Domain taking' \<subseteq> students')
\<and> (Range taking' \<subseteq> degModules')
)"
by blast

(*Here I add other safety properties about the ModuleReg specification 
which I wish to prove*)

lemma pre_AddStudent:
"(\<exists> modulereg modulereg' students' degModules' taking'.
AddStudent modulereg modulereg' p degModules' students' taking')
\<longleftrightarrow> (p \<notin> students)"
apply (unfold AddStudent_def)
apply auto
done

lemma pre_RegForModule:
"(\<exists> modulereg modulereg' students' degModules' taking'.
RegForModule modulereg modulereg' p m degModules' students' taking')
 \<longleftrightarrow> (p \<in> students)
 \<and> (m \<in> degModules)
 \<and> ((p,m) \<notin> taking)"
 apply (unfold RegForModule_def)
 apply auto
done

definition InitModuleReg::
"ModuleReg \<Rightarrow> PERSON set \<Rightarrow> MODULE set \<Rightarrow> (PERSON * MODULE) set \<Rightarrow> bool"
where
"InitModuleReg modulereg' students' degmodules' taking' == ((
(students' = {})
\<and> (degmodules' = {})
\<and> (taking' = {})))"

lemma InitOK:
"(\<exists> modulereg'. InitModuleReg modulereg' students' degmodules' taking')
\<longrightarrow>  ((
(students' = {})
\<and> (degmodules' = {})
\<and> (taking' = {})))
\<and> ((Domain taking' \<subseteq> students')
\<and> (Range taking' \<subseteq> degModules'))"
by (simp add: InitModuleReg_def)

lemma RegForModuleNotEmpty:
"(\<exists> modulereg modulereg' students' degModules' taking' p m.
RegForModule modulereg modulereg' students' degModules' taking' p m)
 \<longrightarrow> (students \<noteq> {})
 \<and> (degModules \<noteq> {})"
by (smt RegForModule_def empty_iff empty_iff)

lemma notEmpty:
"(taking' = taking \<union> {(p,m)}) \<longrightarrow> (taking' \<noteq> {})"
by (smt Un_empty insert_not_empty)

end
end
