\chapter{Specifications in ZMathLang}
\label{app:other}

\section{Vending Machine}
\label{app:vm}

\subsection{Raw Latex}
\label{app:vm0}
%\input{examples/vm/0.tex}
\includegraphics[scale=0.5]{examples/vm/0imagea.png}

\noindent \includegraphics[scale=0.5]{examples/vm/0imageb.png}
\subsection{Raw Latex output}
\label{app:vm0o}

\includegraphics[clip, trim=5cm 5.5cm 5cm 5cm]{examples/vm/0comp.pdf}

\noindent \includegraphics[clip, trim=5cm 22cm 5cm 3.5cm]{examples/vm/0comp2.pdf}
%\includepdf[pages={1-2}]{examples/vm/0comp.pdf}
\subsection{ZCGa Annotated Latex Code}
\label{app:vm1}
\includegraphics[scale=0.5]{examples/vm/1imagea.png}

\noindent \includegraphics[scale=0.5]{examples/vm/1imageb.png}
%\input{examples/vm/1.tex}
\subsection{ZCGa output}
\label{app:vm1o}
\includegraphics[clip, trim=5cm 7cm 5cm 4.2cm]{examples/vm/1comp.pdf}

\noindent \includegraphics[clip, trim=4cm 7cm 5cm 4cm]{examples/vm/1comp2.pdf}
%\includepdf[pages={1-2}]{examples/vm/1comp.pdf}
\subsection{ZDRa Annotated Latex Code}
\label{app:vm2}
\includegraphics[scale=0.5]{examples/vm/2imagea.png}

\noindent \includegraphics[scale=0.5]{examples/vm/2imageb.png}

\noindent \includegraphics[scale=0.5]{examples/vm/2imagec.png}
%\input{examples/vm/2.tex}
\subsection{ZDRa Output}
\label{app:vm2o}

\includegraphics[clip, trim=3cm 7cm 6cm 4.2cm]{examples/vm/2comp.pdf}

%\includepdf[pages={1}]{examples/vm/2comp.pdf}
\subsection{ZCGa and ZDRa Annotated Latex Code}
\label{app:vm1n2}
\includegraphics[scale=0.5]{examples/vm/1n2imagea.png}

\noindent \includegraphics[scale=0.5]{examples/vm/1n2imageb.png}

\noindent \includegraphics[scale=0.5]{examples/vm/1n2imagec.png}

%\input{examples/vm/1n2.tex}
\subsection{ZCGa and ZDRa Output}
\label{app:vm1n2o}
\includegraphics[clip, trim=3cm 4cm 6cm 4.2cm]{examples/vm/1n2comp.pdf}
%\includepdf[pages={1}]{examples/vm/1n2comp.pdf}
\subsection{Dependency and Goto Graphs}
\label{app:vm2.5}
\includegraphics[scale=0.7]{examples/vm/25a.png}

\includegraphics[scale=0.7]{examples/vm/25b.png}
\subsection{General Proof Skeleton}
\label{app:vm3}
\input{examples/vm/3.txt}
\subsection{Isabelle Proof Skeleton}
\label{app:vm4}
\includegraphics[scale=0.5]{examples/vm/4imagea.png}

\noindent \includegraphics[scale=0.5]{examples/vm/4imageb.png}
%\input{examples/vm/4.thy}
\subsection{Isabelle Filled In}
\label{app:vm5}
\includegraphics[scale=0.5]{examples/vm/5imagea.png}

\noindent \includegraphics[scale=0.5]{examples/vm/5imageb.png}

\noindent \includegraphics[scale=0.5]{examples/vm/5imagec.png}
%\input{examples/vm/5.thy}
\subsection{Full Proof in Isabelle}
\label{app:vm6}
\includegraphics[scale=0.5]{examples/vm/6imagea.png}

\noindent \includegraphics[scale=0.5]{examples/vm/6imageb.png}

\noindent \includegraphics[scale=0.5]{examples/vm/6imagec.png}

\noindent \includegraphics[scale=0.5]{examples/vm/6imaged.png}

\noindent \includegraphics[scale=0.5]{examples/vm/6imagee.png}
%\input{examples/vm/6.thy}

\section{BirthdayBook}
\label{app:bb}

\subsection{Raw Latex}
\label{app:bb0}
\includegraphics[scale=0.5]{examples/bb/0imagea.png}

\noindent \includegraphics[scale=0.5]{examples/bb/0imageb.png}
%\input{examples/bb/0.tex}
\subsection{Raw Latex ouput}
\label{app:bb0o}

\noindent \includegraphics[clip, trim=4cm 5.5cm 4cm 4.2cm]{examples/bb/0comp.pdf}

\noindent \includegraphics[clip, trim=4cm 10cm 4cm 4.2cm]{examples/bb/0comp2.pdf}

%\includepdf[pages={1-2}]{examples/bb/0comp.pdf}
\subsection{ZCGa Annotated Latex Code}
\label{app:bb1}
\includegraphics[scale=0.5]{examples/bb/1imagea.png}

\noindent \includegraphics[scale=0.5]{examples/bb/1imageb.png}
%\input{examples/bb/1.tex}
\subsection{ZCGa output}
\label{app:bb1o}
\noindent \includegraphics[clip, trim=4cm 6cm 4cm 4.2cm]{examples/bb/1comp.pdf}

\noindent \includegraphics[clip, trim=4cm 8cm 4cm 4.2cm]{examples/bb/1comp2.pdf}

\noindent \includegraphics[clip, trim=4cm 8cm 4cm 4.2cm]{examples/bb/1comp3.pdf}

\subsection{ZDRa Annotated Latex Code}
\label{app:bb2}
\includegraphics[scale=0.5]{examples/bb/2imagea.png}

\noindent \includegraphics[scale=0.5]{examples/bb/2imageb.png}

\noindent \includegraphics[scale=0.5]{examples/bb/2imagec.png}
%\input{examples/bb/2.tex}
\subsection{ZDRa Output}
\label{app:bb2o}

\noindent \includegraphics[clip, trim=0cm 4cm 6cm 4.2cm]{examples/bb/2comp.pdf}

%\includepdf[pages={1}]{examples/bb/2comp.pdf}
\subsection{ZCGa and ZDRa Annotated Latex Code}
\label{app:bb1n2}
\includegraphics[scale=0.5]{examples/bb/1n2imagea.png}

\noindent \includegraphics[scale=0.5]{examples/bb/1n2imageb.png}

\noindent \includegraphics[scale=0.5]{examples/bb/1n2imagec.png}
%\input{examples/bb/1n2.tex}
\subsection{ZCGa and ZDRa output}
\label{app:bb1n2o}
\noindent \includegraphics[clip, trim=0cm 4cm 6cm 4.2cm]{examples/bb/1n2comp.pdf}

\subsection{Dependency and Goto Graphs}
\label{app:bb2.5}
\includegraphics[scale=0.7]{examples/bb/25a.png}

\includegraphics[scale=0.7]{examples/bb/25b.png}
\subsection{General Proof Skeleton}
\label{app:bb3}
\input{examples/bb/new3.txt}
\subsection{Isabelle Proof Skeleton}
\label{app:bb4}
\includegraphics[scale=0.5]{examples/bb/4imagea.png}

\noindent \includegraphics[scale=0.5]{examples/bb/4imageb.png}

\noindent \includegraphics[scale=0.5]{examples/bb/4imagec.png}
%\input{examples/bb/new4.thy}
\subsection{Isabelle Filled In}
\label{app:bb5}
\includegraphics[scale=0.4]{examples/bb/5imagea.png}

\noindent \includegraphics[scale=0.4]{examples/bb/5imageb.png}

\noindent \includegraphics[scale=0.4]{examples/bb/5imagec.png}
%\input{examples/bb/new4.thy}
%\input{examples/bb/new5.thy}
\subsection{Full Proof in Isabelle}
\label{app:bb6}
\includegraphics[scale=0.4]{examples/bb/6imagea.png}

\noindent \includegraphics[scale=0.4]{examples/bb/6imageb.png}

\noindent \includegraphics[scale=0.4]{examples/bb/6imagec.png}

\noindent \includegraphics[scale=0.4]{examples/bb/6imaged.png}

\noindent \includegraphics[scale=0.4]{examples/bb/6imagee.png}
%\input{examples/bb/new6.thy}

\section{An example of a specification which fails \gls{zcga} but passes \gls{zdra}}
This section shows an example of a specification which is rhetorically correct and passes the \gls{zdra} check however the grammar of the specification is incorrect and therefore fails the \gls{zcga} check. We input the compiled output for each of the examples. For reference to the code the reader is directed to \cite{mathlangexamples}.

%\subsection{Raw Latex}
%\input{examples/nonworkzcga/0.tex}
\subsection{Raw Latex output}

\noindent \includegraphics[clip, trim=4cm 8cm 4cm 4.2cm]{examples/nonworkzcga/0.pdf}

\noindent \includegraphics[clip, trim=4cm 8cm 4cm 4.2cm]{examples/nonworkzcga/0comp2.pdf}

%\includepdf[pages={1-2}]{examples/nonworkzcga/0.pdf}
%\subsection{ZCGa and ZDRa Annotated Latex Code}
%\input{examples/nonworkzcga/1n2.tex}
\subsection{ZCGa and ZDRa output}
\noindent \includegraphics[clip, trim=0cm 4cm 6cm 4.2cm]{examples/nonworkzcga/1n2.pdf}

\subsection{Messages when running the specification through the ZCGa and ZDRa checks}

\begin{figure}[H]
\includegraphics[scale=0.7]{examples/nonworkzcga/incorrect.png}
\caption{Message when checking the specification for ZCGa correctness.}
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.7]{examples/nonworkzcga/correct.png}
\caption{Message when checking the specification for ZDRa correctness.}
\end{figure}

\section{An example of a specification which fails \gls{zdra} but passes \gls{zcga}}
This section shows an example of a specification which is grammatically correct and passes the \gls{zcga} check however there are loops in it's rhetorical reasoning and therefore fails the \gls{zdra} check. We input the compiled output for each of the examples. For reference to the code the reader is directed to \cite{mathlangexamples}.

%\subsection{Raw Latex}
%\input{examples/nonworkzdra/0.tex}
\subsection{Raw Latex output}
%\includepdf[pages={1-3}]{examples/nonworkzdra/0.pdf}
\noindent \includegraphics[clip, trim=4cm 5.5cm 4cm 4.2cm, scale=0.9]{examples/nonworkzdra/0.pdf}

\noindent \includegraphics[clip, trim=4cm 4cm 4cm 4.2cm]{examples/nonworkzdra/0comp2.pdf}

\noindent \includegraphics[clip, trim=4cm 8cm 0cm 4.2cm]{examples/nonworkzdra/0comp3.pdf}
%\subsection{ZCGa and ZDRa Annotated Latex Code}
%\input{examples/nonworkzdra/1n2.tex}
\subsection{ZCGa and ZDRa output}
\noindent \includegraphics[clip, trim=0cm 4cm 6cm 4.2cm]{examples/nonworkzdra/1n2.pdf}

\subsection{Messages when running the specification through the ZCGa and ZDRa checks}

\begin{figure}[H]
\includegraphics[scale=0.7]{examples/nonworkzdra/correct.png}
\caption{Message when checking the specification for ZCGa correctness.}
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.7]{examples/nonworkzdra/incorrect.png}
\caption{Message when checking the specification for ZDRa correctness.}
\end{figure}

\section{An example of a specification which is semi formal}
This section shows an auto pilot specification which is partially written in natural language and partially written formally. Thus it is a natural langauge specification which is on it's way to being formalised.

%\subsection{Raw Latex}
%\input{examples/semiform/0.tex}
\subsection{Raw Latex output}
\noindent \includegraphics[clip, trim=4cm 4cm 4cm 4.2cm, scale=0.9]{examples/semiform/0.pdf}

\noindent \includegraphics[clip, trim=4cm 4cm 4cm 4.2cm, scale=0.9]{examples/semiform/0comp2.pdf}
%\includepdf[pages={1-2}]{examples/semiform/0.pdf}
\subsection{ZCGa and ZDRa Annotated Latex Code}
\includegraphics[scale=0.5]{examples/semiform/1n2a.png}

\noindent \includegraphics[scale=0.5]{examples/semiform/1n2b.png}

\noindent \includegraphics[scale=0.5]{examples/semiform/1n2c.png}
%\input{examples/semiform/1n2images.tex}
\subsection{ZCGa and ZDRa output}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\noindent \includegraphics[clip, trim=left lower right upper]{examples/bb/1comp3.pdf}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\includepdf[pages={1-3}]{examples/bb/1comp.pdf}
\noindent \includegraphics[clip, trim=0cm 4cm 6cm 1.5cm]{examples/semiform/1n2.pdf}

\subsection{Messages when running the specification through the ZCGa and ZDRa checks}

\begin{figure}[H]
\includegraphics[scale=0.7]{examples/semiform/zcgacorrect.png}
\caption{Message when checking the specification for ZCGa correctness.}
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.7]{examples/semiform/zdracorrect.png}
\caption{Message when checking the specification for ZDRa correctness.}
\end{figure}

\subsection{General Proof Skeleton}
\label{app:semiform3}
\input{examples/semiform/3.txt}

\subsection{Isabelle Proof Skeleton}
\label{app:semiform4}
\includegraphics[scale=0.5]{examples/semiform/4image.png}

\subsection{Isabelle Filled In}
\label{app:semiform5}
\includegraphics[scale=0.4]{examples/semiform/5imagea.png}

\noindent \includegraphics[scale=0.4]{examples/semiform/5imageb.png}

%\section{An example of a specification which \\ a changeSchema which does not comply with the stateInvariants}
%This section shows a specification which is \gls{zcga} and \gls{zdra} correct however when it translates to Isabelle syntax one of the proof obligations can not be satisfied as a changeSchema does  not comply with the stateInvariants.

%\subsection{Raw Latex}
%\input{examples/semiform/0.tex}
%\subsection{Raw Latex output}
%\includepdf[pages={1-2}]{examples/semiform/0.pdf}
%\subsection{ZCGa and ZDRa Annotated Latex Code}
%\input{examples/semiform/1n2.tex}
%\subsection{ZCGa and ZDra output}
%\includepdf[pages={1}]{examples/semiform/1n2.pdf}


\section{ModuleReg}
\label{app:moduleregfullproof}

\subsection{ModuleReg Full Proof}

This section shows the full proof for the modulereg example from \cite{essenceofz}. It includes the filled in Isabelle skeleton. Along with added proofs which have been input by the user.

\noindent \includegraphics[scale=0.5]{examples/modulereg/6imagea.png}

\noindent \includegraphics[scale=0.5]{examples/modulereg/6imageb.png}

\noindent \includegraphics[scale=0.5]{examples/modulereg/6imagec.png}

\noindent \includegraphics[scale=0.5]{examples/modulereg/6imaged.png}

\noindent \includegraphics[scale=0.5]{examples/modulereg/6imagee.png}

\noindent \includegraphics[scale=0.5]{examples/modulereg/6imagef.png}

%\input{examples/modulereg/new6.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%CURRIES SPECIFICATIONS%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\chapter{Curries ZMathLang Path}
%\label{app:curries}
%
%\section{Clubstate}
%
%\subsection{Raw Latex}
%
%\input{examples/clubstate/0.tex}
%
%\subsection{Raw Latex output}
%
%\includepdf[pages={1-3}]{examples/clubstate/0.pdf}
%
%\subsection{ZCGa Annotated Latex Code}
%
%\input{examples/clubstate/1.tex}
%
%\subsection{ZCGa output}
%
%\includepdf[pages={1-5}]{examples/clubstate/1.pdf}
%
%\subsection{ZDRa Annotated Latex Code}
%
%\input{examples/clubstate/2.tex}
%
%\subsection{ZDRa Output}
%
%\includepdf[pages={1}]{examples/clubstate/2.pdf}
%
%\subsection{ZCGa and ZDRa Annotated Latex Code}
%
%\input{examples/clubstate/1n2.tex}
%
%\subsection{ZCGa and ZDRa Output}
%
%\includepdf[pages={1}]{examples/clubstate/1n2.pdf}
%
%\subsection{Dependency and Goto Graphs}
%
%\includegraphics[scale=0.7]{examples/clubstate/25a.png}
%
%\includegraphics[scale=0.7]{examples/clubstate/25b.png}
%
%\subsection{General Proof Skeleton}
%
%\input{examples/clubstate/3.txt}
%
%\subsection{Isabelle Proof Skeleton}
%
%\input{examples/clubstate/4.thy}
%
%\subsection{Isabelle Filled In}
%
%\input{examples/clubstate/5.thy}
%
%\subsection{Full Proof in Isabelle}
%
%%\input{examples/clubstate/6.thy}
%\todo[inline]{Complete proof for Clubstate}
%
%\section{ModuleReg}
%\label{app:modulereg}
%
%\subsection{Raw Latex Code}
%
%\input{examples/modulereg/0.tex}
%
%\subsection{Raw Latex Output}
%
%\includepdf[pages={1}]{examples/modulereg/0.pdf}
%
%\subsection{ZCGa Annotated Latex Code}
%
%\input{examples/modulereg/1.tex}
%
%\subsection{ZCGa output}
%
%\includepdf[pages={1-2}]{examples/modulereg/1.pdf}
%
%\subsection{ZDRa Annotated Latex Code}
%
%\input{examples/modulereg/2.tex}
%
%\subsection{ZDRa Output}
%
%\includepdf[pages={1}]{examples/modulereg/2.pdf}
%
%\subsection{ZCGa and ZDRa Annotated Latex Code}
%
%\input{examples/modulereg/1n2.tex}
%
%\subsection{ZCGa and ZDRa output}
%
%\includepdf[pages={1}]{examples/modulereg/1n2.pdf}
%
%\subsection{Dependency and Goto Graphs}
%
%\includegraphics[scale=0.7]{examples/modulereg/25a.png}
%
%\includegraphics[scale=0.7]{examples/modulereg/25b.png}
%
%\subsection{General Proof Skeleton}
%
%\input{examples/modulereg/3.txt}
%
%\subsection{Isabelle Proof Skeleton}
%
%\input{examples/modulereg/4.thy}
%
%\subsection{Isabelle Filled In}
%
%\input{examples/modulereg/5.thy}
%
%\subsection{Full Proof in Isabelle}
%
%\input{examples/modulereg/6.thy}
%
%\section{Video Shop}
%
%\subsection{Raw Latex}
%
%\input{examples/videoshop/0.tex}
%
%\subsection{Raw Latex output}
%
%\includepdf[pages={1-4}]{examples/videoshop/0.pdf}
%
%\subsection{ZCGa Annotated Latex Code}
%
%\input{examples/videoshop/1.tex}
%
%\subsection{ZCGa output}
%
%\includepdf[pages={1-8}]{examples/videoshop/1.pdf}
%
%\subsection{ZDRa Annotated Latex Code}
%
%\input{examples/videoshop/2.tex}
%
%\subsection{ZDRa Output}
%
%\includepdf[pages={1}]{examples/videoshop/2.pdf}
%
%\subsection{ZCGa and ZDRa Latex Code}
%
%\input{examples/videoshop/1n2.tex}
%
%\subsection{ZCGa and ZDRa output}
%
%\includepdf[pages={1}]{examples/videoshop/1n2.pdf}
%
%\subsection{Dependency and Goto Graphs}
%
%\includegraphics[scale=0.7]{examples/videoshop/25a.png}
%
%\includegraphics[scale=0.7]{examples/videoshop/25b.png}
%
%\subsection{General Proof Skeleton}
%
%\input{examples/videoshop/3.txt}
%
%\subsection{Isabelle Proof Skeleton}
%
%\input{examples/videoshop/4.thy}
%
%\subsection{Isabelle Filled In}
%
%\input{examples/videoshop/5.thy}
%
%\subsection{Full Proof in Isabelle}
%
%%\input{examples/clubstate/6.thy}
%\todo[inline]{Complete proof for Videoshop}
%
%\section{Clubstate2}
%
%\subsection{Raw Latex Code}
%
%\input{examples/clubstate2/0.tex}
%
%\subsection{Raw Latex Output}
%
%\includepdf[pages={1-2}]{examples/clubstate2/0.pdf}
%
%\subsection{ZCGa Annotated Latex Code}
%
%\input{examples/clubstate2/1.tex}
%
%\subsection{ZCGa Output}
%
%\includepdf[pages={1-3}]{examples/clubstate2/1.pdf}
%
%\subsection{ZDRa Annotated Latex Code}
%
%\input{examples/clubstate2/2.tex}
%
%\subsection{ZDRa Output}
%
%\includepdf[pages={1}]{examples/clubstate2/2.pdf}
%
%\subsection{ZCGa and ZDRa Code}
%
%\input{examples/clubstate2/1n2.tex}
%
%\subsection{ZCGa and ZDRa Output}
%
%\includepdf[pages={1}]{examples/clubstate2/1n2.pdf}
%
%\subsection{Dependency and Goto Graphs}
%
%\includegraphics[scale=0.7]{examples/clubstate2/25a.png}
%
%\includegraphics[scale=0.7]{examples/clubstate2/25b.png}
%
%\subsection{General Proof Skeleton}
%
%\input{examples/clubstate2/3.txt}
%
%\subsection{Isabelle Proof Skeleton}
%
%\input{examples/clubstate2/4.thy}
%
%\subsection{Isabelle Filled In}
%
%\input{examples/clubstate2/5.thy}
%
%\subsection{Full Proof in Isabelle}
%
%\input{examples/clubstate2/6.thy}
%
%
%\section{Project Alloc}
%
%\subsection{Raw Latex Code}
%
%\input{examples/projectalloc/0.tex}
%
%\subsection{Raw Latex Output}
%
%\includepdf[pages={1-4}]{examples/projectalloc/0.pdf}
%
%\subsection{ZCGa Annotated Latex Code}
%
%\input{examples/projectalloc/1.tex}
%
%\subsection{ZCGa output}
%
%\includepdf[pages={1-10}]{examples/projectalloc/1.pdf}
%
%\subsection{ZDRa Annotated Latex Code}
%
%\input{examples/projectalloc/1.tex}
%
%\subsection{ZDRa Output}
%
%\includepdf[pages={1}]{examples/projectalloc/2.pdf}
%
%\subsection{ZCGa and ZDRa Annotated Latex Code}
%
%\input{examples/projectalloc/1n2.tex}
%
%\subsection{ZCGa and ZDRa Output}
%
%\includepdf[pages={1}]{examples/projectalloc/1n2.pdf}
%
%\subsection{Dependency and Goto Graphs}
%
%\includegraphics[scale=0.7]{examples/projectalloc/25a.png}
%
%\includegraphics[scale=0.7]{examples/projectalloc/25b.png}
%
%\subsection{General Proof Skeleton}
%
%\input{examples/projectalloc/3.txt}
%
%\subsection{Isabelle Proof Skeleton}
%
%\input{examples/projectalloc/4.thy}
%
%\subsection{Isabelle Filled In}
%
%\input{examples/projectalloc/5.thy}
%
%\subsection{Full Proof in Isabelle}
%
%%\input{examples/clubstate/6.thy}
%\todo[inline]{Complete proof for ProjectAlloc}
%
%\section{Timetable}
%\label{app:timetable}
%
%\subsection{Raw Latex Code}
%
%\input{examples/timetable/0.tex}
%
%\subsection{Raw Latex Output}
%
%\includepdf[pages={1-2}]{examples/timetable/0.pdf}
%
%\subsection{ZCGa Annotated Latex Code}
%
%\input{examples/timetable/1.tex}
%
%\subsection{ZCGa output}
%
%\includepdf[pages={1-5}]{examples/timetable/1.pdf}
%
%\subsection{ZDRa Annotated Latex Code}
%
%\input{examples/timetable/2.tex}
%
%\subsection{ZDRa Output}
%
%\includepdf[pages={1}]{examples/timetable/2.pdf}
%
%\subsection{ZCGa and ZDRa Latex Code}
%
%\input{examples/timetable/1n2.tex}
%
%\subsection{ZCGa and ZDRa output}
%
%\includepdf[pages={1}]{examples/timetable/1n2.pdf}
%
%\subsection{Dependency and Goto Graphs}
%
%\includegraphics[scale=0.7]{examples/timetable/25a.png}
%
%\includegraphics[scale=0.7]{examples/timetable/25b.png}
%
%\subsection{General Proof Skeleton}
%
%\input{examples/timetable/3.txt}
%
%\subsection{Isabelle Proof Skeleton}
%
%\input{examples/timetable/4.thy}
%
%\subsection{Isabelle Filled In}
%
%\input{examples/timetable/5.thy}
%
%\subsection{Full Proof in Isabelle}
%
%%\input{examples/timetable/6.thy}
%\todo[inline]{Complete proof for Timetable}
%
%
%\section{GenDB}
%\label{app:gendb}
%
%\subsection{Raw Latex}
%
%\subsection{ZCGa Annotated Latex Code}
%
%\subsection{ZCGa output}
%
%\subsection{ZDRa Annotated Latex Code}
%
%\subsection{ZDRa Output}
%
%\subsection{Dependency and Goto Graphs}
%
%\subsection{General Proof Skeleton}
%
%\subsection{Isabelle Proof Skeleton}
%
%\subsection{Isabelle Filled In}
%
%\subsection{Full Proof in Isabelle}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% OTHER SPECIFICATIONS %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\chapter{Specifications}
%
%
%\section{Vending Machine}
%\label{app:vmspec}
%\begin{verbatim}
%\documentclass{article}
%\usepackage{zed}
%
%\begin{document}
%
%\begin{zed}
%price:\nat
%\end{zed}
%
%\begin{schema}{VMSTATE}
%stock, takings: \nat
%\end{schema}
%
%\begin{schema}{VM\_operation}
%\Delta VMSTATE \\
%cash\_tendered?, cash\_refunded!: \nat \\
%bars\_delivered! : \nat
%\end{schema}
%
%\begin{schema}{exact\_cash}
%cash\_tendered?: \nat
%\where
%cash\_tendered? = price
%\end{schema}
%
%\begin{schema}{insufficient\_cash}
%cash\_tendered? : \nat
%\where
%cash\_tendered? < price
%\end{schema}
%
%\begin{schema}{some\_stock}
%stock: \nat
%\where
%stock > 0
%\end{schema}
%
%\begin{schema}{VM\_sale}
%VM\_operation
%\where
%stock' = stock -1 \\
%bars\_delivered! = 1 \\
%cash\_refunded! = cash\_tendered? - price \\
%takings' = takings + price
%\end{schema}
%
%\begin{schema}{VM\_nosale}
%VM\_operation
%\where
%stock' = stock \\
%bars\_delivered! = 0 \\
%cash\_refunded! = cash\_tendered?\\
%takings' = takings
%\end{schema}
%
%\begin{zed}
%VM1 \defs exact\_cash \land some\_stock \land VM\_sale
%\end{zed}
%
%\begin{zed}
%VM2 \defs insufficient\_cash \land VM\_nosale
%\end{zed}
%
%\begin{zed}
%VM3 \defs VM1 \lor VM2
%\end{zed}
%
%\end{document}
%\end{verbatim}
%
%\section{Birthday Book}
%\label{app:bbspec}
%\begin{verbatim}
%\documentclass{article}
%\usepackage{zed}
%
%\begin{document}
%
%\begin{zed}
%   [NAME, ~ DATE] 
%\end{zed}
%
%\begin{schema}{BirthdayBook}
%known: \power NAME \\ 
%birthday: NAME \pfun DATE 
%\where 
%	known=\dom birthday
%\end{schema}
%
%\begin{schema}{InitBirthdayBook} 
%BirthdayBook~' 
%\where 
%	known' = \{ \}
%\end{schema}
%
%\begin{schema}{AddBirthday}
%    \Delta BirthdayBook \\
%    name?: NAME \\
%    date?: DATE
%\where
%    name? \notin known\\
%    birthday' = birthday \cup \{name? \mapsto date?\}
%\end{schema}
%
%\begin{schema}{FindBirthday}
%    \Xi BirthdayBook \\
%    name?: NAME \\
%    date!: DATE 
%\where
%    	name? \in known\\
%    	date! = birthday(name?)
%\end{schema}
%
%\begin{zed} 
%    REPORT ::= ok | already\_known | not\_known
%\end{zed}
%
%\begin{schema}{Success}
%    result!: REPORT
%\where
%    result! = ok
%\end{schema}
%
%\begin{schema}{AlreadyKnown}
%    \Xi BirthdayBook \\
%    name?: NAME \\
%    result!: REPORT
%\where
%	name? \in known \\
%	result! = already\_known
%\end{schema}
%
%\begin{schema}{NotKnown}
%    \Xi BirthdayBook \\
%    name?: NAME \\
%    result!: REPORT
%\where
%	name? \notin known \\
%	result! = not\_known
%\end{schema}
%
%\begin{zed} 
%    RAddBirthday ==\\ (AddBirthday \land Success)\\
%      \lor AlreadyKnown \\
%    RFindBirthday ==\\ (FindBirthday \land Success)
%     \lor NotKnown \\
%\end{zed}
%
%\end{document}
%\end{verbatim}
%
%\chapter{Proofs}
%
%\section{Vending Machine in \gls{ppz}}
%\label{app:vm_ppz}
%
%\begin{verbatim}
%repeat drop_main_goal;
%open_theory "z_exercises_3";
%set_pc "z_library";
%set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
%
%%SFT%ZAX
%%BV%	price :%bbN%
%%EFT%
%
%%SZS%VMSTATE%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	stock, takings :%bbN%
%%EZ%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%
%%SZS%VM_operation%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	%Delta%VMSTATE;
%%BV%	cash_tendered?, cash_refunded! :%bbN%;
%%BV%	bars_delivered! :%bbN%
%%EZ%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%
%%SZS%exact_cash%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	cash_tendered? :%bbN%
%%BT%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	cash_tendered? = price
%%EZ%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%
%%SZS%insufficient_cash%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	cash_tendered? :%bbN%
%%BT%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	cash_tendered? < price
%%EZ%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%
%%SZS%some_stock%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	stock :%bbN%
%%BT%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	stock > 0
%%EZ%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%
%%SZS%VM_sale%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	VM_operation
%%BT%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	stock' = stock - 1;
%%BV%	bars_delivered! = 1;
%%BV%	cash_refunded! = cash_tendered? - price;
%%BV%	takings' = takings + price
%%EZ%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%
%%SZS%VM_nosale%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	VM_operation
%%BT%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	stock' = stock;
%%BV%	bars_delivered! = 0;
%%BV%	cash_refunded! = cash_tendered?;
%%BV%	takings' = takings
%%EZ%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%
%%SFT%Z
%%BV%	VM1 %def% exact_cash %and% some_stock %and% VM_sale
%%EFT%
%
%%SFT%Z
%%BV%	VM2 %def% insufficient_cash %and% VM_nosale
%%EFT%
%
%%SFT%Z
%%BV%	VM3 %def% VM1 %or% VM2
%%EFT%
%
%val [price, VMSTATE, VM_operation, exact_cash,
%    insufficient_cash, some_stock, VM_sale,
%    VM_nosale, VM1, VM2, VM3]
% = map z_get_spec [%SZT%price%>%,%SZT%VMSTATE%>%,
% %SZT%VM_operation%>%,%SZT%exact_cash%>%,
%    %SZT%insufficient_cash%>%,%SZT%some_stock%>%,%SZT%VM_sale%>%,
%    %SZT%VM_nosale%>%,%SZT%VM1%>%,%SZT%VM2%>%,%SZT%VM3%>%];
%
%set_goal([],%SZT%pre VM1 %equiv% 
%	(0 < stock
%	%and% cash_tendered? = price
%	%and% 0 %leq% takings)%>%);
%a (rewrite_tac [VM1, VM_sale, some_stock,
% VM_operation, VMSTATE, exact_cash]);
%a (pure_rewrite_tac [z_get_spec %SZT%(_ %leq% _)%>%]);
%a (rewrite_tac[]);
%a (REPEAT z_strip_tac);
%a (z_%exists%_tac %SZT%(
%	bars_delivered! %def% 1,
%	cash_refunded! %def% cash_tendered? + ~ price,
%	stock' %def% stock + ~ 1,
%	takings' %def% takings + price)%>%
%   THEN rewrite_tac[]);
%a (PC_T1 "z_library_ext" asm_rewrite_tac
%   [rewrite_rule [] price]);
%a (LEMMA_T %SZT%stock + ~ 1 %leq% stock%>% asm_tac 
%THEN1 rewrite_tac[]);
%a (all_fc_tac [z_%leq%_trans_thm]);
%a (asm_rewrite_tac []);
%a (strip_asm_tac (z_get_spec %SZT%price%>%));
%a (all_fc_tac [z_%bbN%_plus_thm]);
%val pre_VM1_thm = save_pop_thm "pre_VM1_thm";
%
%set_goal([], %SZT%pre VM2 %equiv% 
%	cash_tendered? < price
%	%and% cash_tendered? %geq% 0
%	%and% stock %geq% 0
%	%and% takings %geq% 0%>%);
%a (rewrite_tac [VM2, VM_nosale, VM_operation,
%VMSTATE, insufficient_cash]);
%a (REPEAT z_strip_tac);
%a (z_%exists%_tac %SZT%(
%	bars_delivered! %def% 0,
%	cash_refunded! %def% cash_tendered?,
%	stock' %def% stock,
%	takings' %def% takings)%>%
%   THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
%val pre_VM2_thm = save_pop_thm "pre_VM2_thm";
%
%set_goal([], %SZT%pre (VM1 %or% VM2) %equiv% pre VM1 %or% pre VM2%>%);
%a (prove_tac[]);
%val VM1VM2_lemma = pop_thm();
%
%set_goal([],%SZT%pre VM3 %equiv%
%	 0 < stock %and% cash_tendered? = price %and% 0 %leq% takings
%             %or% cash_tendered? < price
%               %and% 0 %leq% cash_tendered?
%               %and% 0 %leq% stock
%               %and% 0 %leq% takings%>%);
%a (pure_rewrite_tac [VM3, VM1VM2_lemma, pre_VM1_thm, pre_VM2_thm]);
%a (z_strip_tac
%	THEN z_strip_tac
%	THEN z_strip_tac
%	THEN strip_asm_tac price
%	THEN asm_rewrite_tac[]);
%val pre_VM3_thm = save_pop_thm "pre_VM3_thm";
%
%set_goal([], %SZT%%not% (insufficient_cash %and% exact_cash)%>%);
%a (rewrite_tac [insufficient_cash, exact_cash]);
%a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
%a (REPEAT_N 3 z_strip_tac THEN asm_rewrite_tac[]);
%val cash_lemma = save_pop_thm "cash_lemma";
%
%set_goal([], %SZT% (pre VM1 %implies% pre VM3) 
%%and% (pre VM1 %and% VM3 %implies% VM1)%>%);
%a (rewrite_tac [VM1, VM2, VM3]);
%a (strip_asm_tac cash_lemma THEN asm_rewrite_tac[]);
%a (REPEAT z_strip_tac);
%val VM3_refines_VM1 = save_pop_thm "VM3_refines_VM1";
%
%%SFT%ZAX
%%BV%	VM_ok : %bbP% %bbP% VM_operation
%%BT%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%%BH%
%%BV%	%forall% vm : %bbP% VM_operation%spot%
%%BV%	vm %mem% VM_ok %equiv%
%%BV%		(%forall% VM_operation %spot% vm %implies%
%%BV%		takings' - takings %geq% price * (stock - stock'))
%%EFT%
%val VM_ok = z_defn_simp_rule (z_get_spec %SZT%VM_ok%>%);
%
%set_goal([], %SZT%VM3 %mem% VM_ok%>%);
%a (rewrite_tac [VM1,VM2,VM3,VM_ok,VM_sale,VM_nosale]);
%a (PC_T "z_library_ext" (REPEAT z_strip_tac) THEN asm_rewrite_tac[]);
%a (rewrite_tac [z_%forall%_elim %SZT%~ takings%>% z_plus_order_thm]);
%a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
%val VM3_ok_thm = save_pop_thm "VM3_ok_thm";
%\end{verbatim}
%
%
%\section{Birthday Book annotated in \gls{hol}}
%\label{app:bb_annotate_hol}
%
%\begin{verbatim}
%
%\section{The Specification}
%
%This document cantains specification and analysis of Spivey's 
%classical BirthdayBook example. It is intended to demonstrate
%the use of the ZETA-frontend to write and typecheck
%specifications in Z, and the Isabelle backend that allows for
%stating and proving proof obligations over this specification.
%
%\subsection{Basic Datatypes and State Schemas}
%\zsection{BBSpec}
%
%\begin{zedgroup}
%  \begin{zed}
%    [NAME,DATE]
%  \end{zed}
%
%  \begin{schema}{BirthdayBook}
%    known: \power NAME \\
%    birthday: NAME \pfun DATE
%    \where
%    known = \dom birthday
%  \end{schema}
%\end{zedgroup}
%
%\subsection{Operations}
%\begin{zed}
% InitBirthdayBook == [BirthdayBook | known = \emptyset] 
%\end{zed}
%
%\begin{zedgroup}
%  \begin{schema}{AddBirthday}
%    \Delta BirthdayBook \\
%    name?: NAME; date?: DATE
%    \where
%    name? \notin known \\
%    birthday' = birthday \cup \{name? \mapsto date?\}
%  \end{schema}
%  \begin{schema}{FindBirthday}
%    \Xi BirthdayBook \\
%    name?: NAME; date!: DATE 
%    \where
%    name? \in known \\
%    date! = birthday(name?)
%  \end{schema}
%  \begin{schema}{Remind}
%    \Xi BirthdayBook \\
%    today?: DATE; cards!: \power NAME
%    \where
%    cards! = \{ n: NAME | n \in known; birthday(n) =  today? \}\\
%  \end{schema}
%\end{zedgroup}
%
%
%\subsection{Strengthening the Specification}
%
%%\zsection[BBSpec]{BBStrength}
%
%\begin{zed}
%  REPORT ::= ok | already\_known | not\_known
%\end{zed}
%
%\begin{schema}{Success}
%  result!: REPORT \\
%  \where
%  result! = ok
%\end{schema}
%
%\begin{schema}{AlreadyKnown}
%  \Xi BirthdayBook \\
%  name?: NAME \\
%  result!: REPORT \\
%  \where
%  name? \in known \\
%  result! = already\_known \\
%\end{schema}
%
%\begin{zed}
%  RAddBirthday == ( AddBirthday \land Success ) \lor AlreadyKnown
%\end{zed}
%
%
%\subsection{Implementing the Birthday Book}
%
%%\zsection[BBSpec]{BBImpl}
%
%\begin{schema}{BirthdayBook1}
%  names: \nat \fun NAME \\
%  dates: \nat \fun DATE \\
%  hwm:   \nat \\
%  \where
%  \forall i,j: 1 \upto hwm @ i \neq j \implies names(i) \neq names(j) \\
%\end{schema}
%
%\begin{zed}
% InitBirthdayBook1 == [ BirthdayBook1 | hwm = 0 ] 
%\end{zed}
%
%\begin{schema}{Abs}
%  BirthdayBook \\
%  BirthdayBook1 \\
%  \where
%  known = \{ i: 1 \upto hwm @ names(i) \} \\
%  \forall i: 1 \upto hwm @ birthday( names(i) ) = dates(i)
%\end{schema}
%
%\begin{schema}{AddBirthday1}
%  \Delta BirthdayBook1 \\
%  name?: NAME \\
%  date?: DATE \\
%  \where
%  \forall i: 1 \upto hwm @ name? \neq names(i) \\
%  hwm' = hwm + 1 \\
%  names' = names \oplus \{ hwm' \mapsto name? \} \\
%  dates' = dates \oplus \{ hwm' \mapsto date? \}
%\end{schema}
%
%
%\subsection{Specification}
%\subsection{Stating Conjectures}
%At times, the designer of a specification might want to state
%a certain property that he has in mind when writing the specification
%document. Such properties can be stated as \emph{conjecture}. ZETA
%can type-check them and export them to HOL-Z; the latter will
%consider a conjecture as definition of an internal constant symbol.
%For proving the conjecture, one states a lemma in the analysis that
%this internal constant symbol is actually equivalent to $True$.
%
%The statement of a conjecture is simply done by:
%
%\begin{zed}
% \forall BirthdayBook; BirthdayBook1; name?:NAME; date?:DATE @  \\
%    name? \notin known \land (known = \{i : 1 \upto hwm @ names(i)\}) \\
%    \implies (\forall i : 1\upto hwm @ name? \neq names(i))
%\end{zed}
%
%
%\subsection{Conclusion}
%In the following, we discuss two versions of analysis: one based on
% relational refinement,
%another on functional refinement, which leads to simpler proof.
%See corresponding \verb+BBSpec.thy+ file for the relational refinement,
%and \verb+BBSpec_Functional.thy+ for the functional refinement.
%
%The following ISAR command starts a new Isabelle 
%theory based on Z, including all libraries and setups. 
%
%%%% Local Variables: 
%%%% mode: latex
%%%% TeX-master: t
%%%% End: 
%\end{verbatim}
%
%\section{Birthday Book in \gls{hol}}
%\label{app:bb_hol}
%
%\begin{verbatim}
%txt{************ BBSpec.holz ***********}
%
%ZAbsy.ZSection("LTX:BBSpec#bbook",["LTX:Toolkit#Toolkit"],
%[(ZAbsy.GivenType("NAME")),
%(ZAbsy.GivenType("DATE")),
%(ZAbsy.Eqn("BirthdayBook", ZAbsy.SchemaText([ZAbsy.Direct(["known"],
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))), ZAbsy.Direct(
%["birthday"], ZAbsy.NameAppl("_pfun_",[ZAbsy.NameAppl("NAME",[]),
%ZAbsy.NameAppl("DATE",[])]))], [ZAbsy.Test(ZAbsy.Tuple([ZAbsy.
%NameAppl("known",[]), ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl
%("dom",[]),ZAbsy.NameAppl("birthday",[]))]), ZAbsy.NameAppl("_=_",
%[]))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([
%("birthday",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.
%NameAppl("NAME",[]), ZAbsy.NameAppl("DATE",[])]))), ("known",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[])))]))))),
%(ZAbsy.Eqn("InitBirthdayBook", ZAbsy.SchemaText([ZAbsy.SchemaName
%("BirthdayBook",ZAbsy.Type
%(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([("birthday",ZAbsy.Unary
%(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.NameAppl
%("DATE",[])]))), ("known",ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl
%("NAME",[])))]))),[])], [ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("known",[]),
%ZAbsy.NameAppl("emptyset",[])]), ZAbsy.NameAppl("_=_"
%,[]))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([("birthday",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), 
%ZAbsy.NameAppl("DATE",[])]))), ("known",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.NameAppl("NAME",[])))]))))),
%(ZAbsy.Eqn("AddBirthday", ZAbsy.SchemaText([ZAbsy.Unary(ZAbsy.Delta,
%ZAbsy.NameAppl("BirthdayBook",[])), ZAbsy.Direct(["name?"], 
%ZAbsy.NameAppl("NAME",[])), ZAbsy.Direct(["date?"], ZAbsy.NameAppl
%("DATE",[]))], [ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("name?",[]),
%ZAbsy.NameAppl("known",[])]), ZAbsy.NameAppl("_notin_",[])), 
%ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("birthday'",[]), ZAbsy.Binary
%(ZAbsy.Apply,ZAbsy.NameAppl("_cup_",[]),ZAbsy.Tuple([ZAbsy.NameAppl
%("birthday",[]), ZAbsy.Display([ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl
%("_mapsto_",[]),ZAbsy.Tuple([ZAbsy.NameAppl("name?",[]), ZAbsy.NameAppl
%("date?",[])]))])]))]), ZAbsy.NameAppl("_=_",[]))]),ZAbsy.Type(ZAbsy.
%Unary(ZAbsy.Power,ZAbsy.Signature([("birthday",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.
%NameAppl("DATE",[])]))), ("birthday'",ZAbsy.Unary(ZAbsy.Power,ZAbsy.
%Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.NameAppl("DATE",[])]))), 
%("date?",ZAbsy.NameAppl("DATE",[])), ("known",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.NameAppl("NAME",[]))), ("known'",ZAbsy.Unary(ZAbsy.Power,ZAbsy.
%NameAppl("NAME",[]))), ("name?",ZAbsy.NameAppl("NAME",[]))]))))),
%(ZAbsy.Eqn("FindBirthday", ZAbsy.SchemaText([ZAbsy.Unary(ZAbsy.Xi,
%ZAbsy.NameAppl("BirthdayBook",[])), ZAbsy.Direct(["name?"], ZAbsy.
%NameAppl("NAME",[])), ZAbsy.Direct(["date!"], ZAbsy.NameAppl("DATE",[]))],
% [ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("name?",[]), ZAbsy.NameAppl
%("known",[])]), ZAbsy.NameAppl("_in_",[])), ZAbsy.Test(ZAbsy.Tuple
%([ZAbsy.NameAppl("date!",[]), ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl
%("birthday",[]),ZAbsy.NameAppl("name?",[]))]), ZAbsy.NameAppl("_=_"
%,[]))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([("birthday",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), 
%ZAbsy.NameAppl("DATE",[])]))), ("birthday'",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.NameAppl("DATE",[])]))),
%("date!",ZAbsy.NameAppl("DATE",[])), ("known",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.NameAppl("NAME",[]))), ("known'",ZAbsy.Unary(ZAbsy.Power,ZAbsy.
%NameAppl("NAME",[]))), ("name?",ZAbsy.NameAppl("NAME",[]))]))))),
%(ZAbsy.Eqn("Remind", ZAbsy.SchemaText([ZAbsy.Unary(ZAbsy.Xi,ZAbsy.NameAppl
%("BirthdayBook",[])), ZAbsy.Direct(["today?"], ZAbsy.NameAppl("DATE",[])),
%ZAbsy.Direct(["cards!"], ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[])))],
%[ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("cards!",[]), ZAbsy.Quantor(ZAbsy.
%Set,[ZAbsy.Direct(["n"], ZAbsy.NameAppl("NAME",[]))], [ZAbsy.Test(ZAbsy.
%Tuple([ZAbsy.NameAppl("n",[]), ZAbsy.NameAppl("known",[])]), ZAbsy.NameAppl("_in_",[])),
%ZAbsy.Test(ZAbsy.Tuple([ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("birthday",[]),
%ZAbsy.NameAppl("n",[])), ZAbsy.NameAppl("today?",[])]), ZAbsy.
%NameAppl("_=_",[]))],ZAbsy.NameAppl("n",[]))]), ZAbsy.NameAppl("_=_",
%]))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([("birthday",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), 
%ZAbsy.NameAppl("DATE",[])]))), ("birthday'",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.NameAppl("DATE",[])]))), ("cards!",ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))), ("known",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))), ("known'",ZAbsy.
%Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))), ("today?",ZAbsy.NameAppl
%("DATE",[]))]))))), (ZAbsy.FreeType("REPORT", [ZAbsy.Constant("ok"),ZAbsy.Constant("already_known"),ZAbsy.Constant("not_known")])),
%(ZAbsy.Eqn("Success", ZAbsy.SchemaText([ZAbsy.Direct(["result!"], ZAbsy.
%NameAppl("REPORT",[]))], [ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl
%("result!",[]), ZAbsy.NameAppl("ok",[])]), ZAbsy.NameAppl("_=_",[]))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([("result!",
%ZAbsy.NameAppl("REPORT",[]))]))))),
%(ZAbsy.Eqn("AlreadyKnown", ZAbsy.SchemaText([ZAbsy.Unary(ZAbsy.Xi,
%ZAbsy.NameAppl("BirthdayBook",[])), ZAbsy.Direct(["name?"], ZAbsy.
%NameAppl("NAME",[])), ZAbsy.Direct(["result!"], ZAbsy.NameAppl("REPORT",[]))], [ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("name?",[]), ZAbsy.NameAppl("known",
%[])]), ZAbsy.NameAppl("_in_",[])), ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("result!",[]),
%ZAbsy.NameAppl("already_known",[])]), ZAbsy.NameAppl("_=_",[]))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([("birthday",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), 
%ZAbsy.NameAppl("DATE",[])]))), ("birthday'",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.NameAppl("DATE",[])]))), ("known",ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))), 
%("known'",ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))), 
%("name?",ZAbsy.NameAppl("NAME",[])), ("result!",ZAbsy.NameAppl("REPORT",[]))]))))),
%(ZAbsy.Eqn("RAddBirthday", ZAbsy.Binary(ZAbsy.Or,ZAbsy.Binary
%(ZAbsy.And,ZAbsy.NameAppl("AddBirthday",[]),ZAbsy.NameAppl("Success",[])),
%ZAbsy.NameAppl("AlreadyKnown",[])),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Signature([("birthday",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), 
%ZAbsy.NameAppl("DATE",[])]))), ("birthday'",ZAbsy.
%Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]),
% ZAbsy.NameAppl("DATE",[])]))), ("date?",ZAbsy.NameAppl("DATE",[])), ("known",ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))),
%("known'",ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[]))),
%("name?",ZAbsy.NameAppl("NAME",[])), ("result!",ZAbsy.NameAppl
%("REPORT",[]))]))))),
%(ZAbsy.Eqn("BirthdayBook1", ZAbsy.SchemaText([ZAbsy.Direct(["names"],
%ZAbsy.NameAppl("_fun_",[ZAbsy.NameAppl("nat",[]),ZAbsy.NameAppl
%("NAME",[])])), ZAbsy.Direct(["dates"], ZAbsy.NameAppl("_fun_",
%[ZAbsy.NameAppl("nat",[]),ZAbsy.NameAppl("DATE",[])])), ZAbsy.Direct(["hwm"],
%ZAbsy.NameAppl("nat",[]))], [ZAbsy.Quantor(ZAbsy.Forall, [ZAbsy.Direct(["i", "j"], ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("_upto_",[]),ZAbsy.Tuple
%([ZAbsy.Number("1"), ZAbsy.NameAppl("hwm",[])])))], [], ZAbsy.Binary(ZAbsy.
%Implies,ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl
%("i",[]), ZAbsy.NameAppl("j",[])]), ZAbsy.NameAppl("_neq_",[])), ZAbsy.Test(ZAbsy.Tuple([ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl
%("names",[]),ZAbsy.NameAppl("i",[])), ZAbsy.Binary(ZAbsy.Apply,
%ZAbsy.NameAppl("names",[]),ZAbsy.NameAppl("j",[]))]), ZAbsy.NameAppl("_neq_",[]))))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature
%([("dates",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("baseNum",[]),
%ZAbsy.NameAppl("DATE",[])]))), ("hwm",ZAbsy.NameAppl("baseNum",[])), ("names",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl
%("baseNum",[]), ZAbsy.NameAppl("NAME",[])])))]))))),
%(ZAbsy.Eqn("InitBirthdayBook1", ZAbsy.SchemaText([ZAbsy.SchemaName
%("BirthdayBook1",ZAbsy.Type(ZAbsy.Unary
%(ZAbsy.Power,ZAbsy.Signature([("dates",ZAbsy.Unary(ZAbsy.Power,ZAbsy.
%Product([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("DATE",[])]))),
%("hwm",ZAbsy.NameAppl("baseNum",[])), ("names",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Product([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("NAME",
%[])])))]))),[])], [ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("hwm",[]),
%ZAbsy.Number("0")]), ZAbsy.NameAppl("_=_",[]))]),ZAbsy.Type(ZAbsy.
%Unary(ZAbsy.Power,ZAbsy.Signature
%([("dates",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl
%("baseNum",[]), ZAbsy.NameAppl("DATE",[])]))), ("hwm",ZAbsy.NameAppl
%("baseNum",[])), ("names",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product
%([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("NAME",[])])))]))))),
%(ZAbsy.Eqn("Abs", ZAbsy.SchemaText([ZAbsy.SchemaName("BirthdayBook"
%ZAbsy.Type(ZAbsy.
%Unary(ZAbsy.Power,ZAbsy.Signature([("birthday",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.NameAppl("DATE",[])]))), ("known",ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[])))]))),[]), ZAbsy.SchemaName("BirthdayBook1",ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Signature([("dates",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.
%NameAppl("baseNum",[]), ZAbsy.NameAppl("DATE",[])]))), ("hwm",ZAbsy.
%NameAppl("baseNum",[])), ("names",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product
%([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("NAME",[])])))]))),[])], 
%[ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("known",[]), ZAbsy.Quantor(ZAbsy.Set,
%ZAbsy.Direct(["i"], ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("_upto_",[]),
%ZAbsy.Tuple([ZAbsy.Number("1"), ZAbsy.NameAppl("hwm",[])])))], [],ZAbsy.
%Binary(ZAbsy.Apply,ZAbsy.NameAppl("names",[]),ZAbsy.NameAppl("i",[])))]),
%ZAbsy.NameAppl("_=_",[])), ZAbsy.Quantor(ZAbsy.Forall, [ZAbsy.Direct(["i"], ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("_upto_",[]),ZAbsy.Tuple([ZAbsy.
%Number("1"), ZAbsy.NameAppl("hwm",[])])))], [], ZAbsy.Test(ZAbsy.Tuple([ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("birthday",[]),ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("names",[]),ZAbsy.NameAppl("i",[]))), ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("dates",[]),ZAbsy.NameAppl("i",[]))]),
%ZAbsy.NameAppl("_=_",[])))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.
%Signature([("birthday",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("NAME",[]), ZAbsy.
%NameAppl("DATE",[])]))), ("dates",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product
%([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("DATE",[])]))), 
%("hwm",ZAbsy.NameAppl("baseNum",[])), ("known",ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.NameAppl("NAME",[]))), ("names",ZAbsy.Unary(ZAbsy.Power,ZAbsy.
%Product([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("NAME",[])])))]))))),
%(ZAbsy.Eqn("AddBirthday1", ZAbsy.SchemaText([ZAbsy.Unary(ZAbsy.Delta,
%ZAbsy.NameAppl("BirthdayBook1",[])), ZAbsy.Direct(["name?"], ZAbsy.
%NameAppl("NAME",[])), ZAbsy.Direct(["date?"], ZAbsy.NameAppl("DATE",[]))],
%[ZAbsy.Quantor(ZAbsy.Forall, [ZAbsy.Direct(["i"], ZAbsy.Binary
%(ZAbsy.Apply,ZAbsy.NameAppl("_upto_",[]),ZAbsy.Tuple([ZAbsy.Number("1"),
%ZAbsy.NameAppl("hwm",[])])))], [], ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl
%("name?",[]), ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("names",[]),ZAbsy.
%NameAppl("i",[]))]), ZAbsy.NameAppl("_neq_",[]))), ZAbsy.Test(ZAbsy.Tuple
%([ZAbsy.NameAppl("hwm'",[]), ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("_+_",[]),
%ZAbsy.Tuple([ZAbsy.NameAppl("hwm",[]), ZAbsy.Number("1")]))]), ZAbsy.NameAppl
%("_=_",[])), ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("names'",[]), ZAbsy.
%Binary(ZAbsy.Apply,ZAbsy.NameAppl("_oplus_",[]),ZAbsy.Tuple([ZAbsy.NameAppl
%("names",[]), ZAbsy.Display([ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("_mapsto_",[]),
%ZAbsy.Tuple([ZAbsy.NameAppl("hwm'",[]), ZAbsy.NameAppl("name?",[])]))])]))]),
%ZAbsy.NameAppl("_=_",[])), ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl("dates'",[]), ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl("_oplus_",[]),ZAbsy.Tuple
%([ZAbsy.NameAppl("dates",[]), ZAbsy.Display([ZAbsy.Binary(ZAbsy.
%Apply,ZAbsy.NameAppl("_mapsto_",[]),ZAbsy.Tuple([ZAbsy.NameAppl
%("hwm'",[]), ZAbsy.NameAppl("date?",[])]))])]))]), ZAbsy.NameAppl("_=_",[]))]),ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,ZAbsy.Signature([("date?",
%ZAbsy.NameAppl("DATE",[])), ("dates",ZAbsy.Unary(ZAbsy.Power,ZAbsy.
%Product([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("DATE",[])]))), ("dates'",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl("baseNum",[]),
%ZAbsy.NameAppl("DATE",[])]))), ("hwm",ZAbsy.NameAppl("baseNum",[])),
%("hwm'",ZAbsy.NameAppl("baseNum",[])), ("name?",ZAbsy.NameAppl
%("NAME",[])), ("names",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product
%([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("NAME",[])]))), ("names'",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product([ZAbsy.NameAppl
%("baseNum",[]), ZAbsy.NameAppl("NAME",[])])))]))))),
%(ZAbsy.SchemaText([], [ZAbsy.Quantor(ZAbsy.Forall, [ZAbsy.SchemaName
%("BirthdayBook",ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power,
%ZAbsy.Signature([("birthday",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product
%([ZAbsy.NameAppl("NAME",[]), ZAbsy.NameAppl("DATE",[])]))), ("known",
%ZAbsy.Unary(ZAbsy.Power,ZAbsy.NameAppl("NAME",[])))]))),[]), ZAbsy.SchemaName("BirthdayBook1",ZAbsy.Type(ZAbsy.Unary(ZAbsy.Power
%,ZAbsy.Signature([("dates",ZAbsy.Unary(ZAbsy.Power,ZAbsy.Product
%([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl("DATE",[])]))), 
%("hwm",ZAbsy.NameAppl("baseNum",[])), ("names",ZAbsy.Unary(ZAbsy.
%Power,ZAbsy.Product([ZAbsy.NameAppl("baseNum",[]), ZAbsy.NameAppl
%("NAME",[])])))]))),[]), ZAbsy.Direct(["name?"], ZAbsy.NameAppl
%("NAME",[])), ZAbsy.Direct(["date?"], ZAbsy.NameAppl("DATE",[]))], [], ZAbsy.Binary(ZAbsy.Implies,ZAbsy.Binary(ZAbsy.And,ZAbsy.Test(ZAbsy
%.Tuple([ZAbsy.NameAppl("name?",[]), ZAbsy.NameAppl("known",[])]), 
%ZAbsy.NameAppl("_notin_",[])), ZAbsy.Test(ZAbsy.Tuple([ZAbsy.NameAppl
%("known",[]), ZAbsy.Quantor(ZAbsy.Set,[ZAbsy.Direct(["i"], ZAbsy.Binary
%(ZAbsy.Apply,ZAbsy.NameAppl("_upto_",[]),ZAbsy.Tuple([ZAbsy.Number("1"),
%ZAbsy.NameAppl("hwm",[])])))], [],ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl
%("names",[]),ZAbsy.NameAppl("i",[])))]), ZAbsy.NameAppl("_=_",[]))),
%ZAbsy.Quantor(ZAbsy.Forall, [ZAbsy.Direct(["i"], ZAbsy.Binary(ZAbsy.
%Apply,ZAbsy.NameAppl("_upto_",[]),ZAbsy.Tuple([ZAbsy.Number("1"),
%ZAbsy.NameAppl("hwm",[])])))], [], ZAbsy.Test(ZAbsy.Tuple([ZAbsy.
%NameAppl("name?",[]), ZAbsy.Binary(ZAbsy.Apply,ZAbsy.NameAppl
%("names",[]),ZAbsy.NameAppl("i",[]))]), ZAbsy.NameAppl("_neq_",[])))))]))])
%
%txt{************ BB.thy.thy ***********}
%
%theory  BB
%imports Fun_Refinement 
%           Rel_Refinement
%begin
%end
%txt{************ BBSpec.thy ***********}
%
%theory  BBSpec
%imports Z
%begin
%ML{* print_mode:= !print_mode @ ["xsymbols"]; *}
%load_holz "BBSpec"
%ML{*
%print_depth 200;
%ZEncoder.PARSES;
%ZEnv.schemas_of(ZTheory.get_zenv(the_context()));
%*}
%thm AddBirthday_def
%thm NAME_def
%thm BBSpec.REPORT.simps
%thm BirthdayBook_def
%thm Remind_def 
%    InitBirthdayBook_def 
%    AddBirthday_def 
%    RAddBirthday_def
%thm SCHEMAS
%thm AXDEFS
%thm CONJECTURES
%lemma conjecture_0_proof : "conjecture_0"
%by(unfold conjecture_0_def,zstrip,
%   zunfold BirthdayBook_def BirthdayBook1_def, auto simp: Z2HOL)
%zlemma PO_refine_1_AddBirthday_simple :
%" \<Sforall> BirthdayBook \<spot> (\<Sforall> BirthdayBook1 \<spot>                                  
%    (\<forall> name? \<in> NAME. \<forall> date? \<in> DATE.         
%      ((name? \<notin> known \<and> known = {n. \<exists> i
%       \<in> 1..hwm. n = names\<rappll>i\<rapplr>})          
%      \<longrightarrow>                                          
%      (\<forall>i \<in> 1..hwm. name? \<noteq> names\<rappll>i\<rapplr>))          
% ))"
%by(zstrip,auto)
%list_po
%check_po
%gen_state_cc BirthdayBook
%gen_state_cc BirthdayBook1
%show_po      BBSpec.ccState_BirthdayBook1_1
%po "BBSpec.ccState_BirthdayBook1_1"
%apply(zintro_sch_ex,clarify,(rule refl)+)
%apply(zunfold BirthdayBook1_def)
%apply(auto simp: Z2HOL)
%apply(rule_tac [3] ZInteg.zero_is_natural, simp_all)
%apply(rule_tac f="\<lambda> x. arbitrary" in lambda_total1,simp)+
%discharged
%gen_op_cc    AddBirthday
%gen_op_cc    AddBirthday1
%show_po      BBSpec.ccOp_AddBirthday1_1
%list_po except ccOp
%end
%txt{************ Fun_Refinement.thy ***********}
%
%theory  Fun_Refinement
%imports BBSpec
%begin
%set_abs "Abs"[functional]
%refine_init InitBirthdayBook InitBirthdayBook1
%refine_op   AddBirthday      AddBirthday1
%show_po Fun_Refinement.fwRefinementInit_BirthdayBook_1
%show_po Fun_Refinement.fwRefinementOp_AddBirthday_2
%list_po
%show_po BBSpec.ccOp_AddBirthday_1 
%        BBSpec.ccOp_AddBirthday1_1 
%        BBSpec.ccState_BirthdayBook_1 
%        BBSpec.ccState_BirthdayBook1_1
%        Fun_Refinement.fwRefinementFunctional_Abs_1
%        Fun_Refinement.fwRefinementOp_AddBirthday_1 
%        Fun_Refinement.fwRefinementOp_AddBirthday_2 
%        Fun_Refinement.fwRefinementInit_BirthdayBook_1
%check_po except ccOp ccState fwRefinementFunctional 
%                fwRefinementOp fwRefinementInit
%lemma lemma1: 
% "\<lbrakk> BirthdayBook1 (dates, hwm, names); i \<in> 
% ( 1 \<upto> hwm); ia \<in> ( 1 \<upto> hwm); 
%    names\<rappll>i\<rapplr> = names\<rappll>ia\<rapplr> \<rbrakk> 
%  \<Longrightarrow> dates\<rappll>i\<rapplr> = dates\<rappll>ia\<rapplr>"
%apply(zunfold BirthdayBook1_def, simp add: Z2HOL, clarify)
%apply(case_tac "i=ia",auto)
%done
%lemma lemma2:
%" (a \<in> (rel_appl names) ` (1 \<upto> hwm)) = (\<exists>i\<in>1 
%\<upto> hwm. names\<rappll>i\<rapplr> = a)"
%apply(auto simp:Z2HOL)
%done
%po "Fun_Refinement.fwRefinementFunctional_Abs_1"
%apply(zstrip)
%apply(simp add:Z2HOL Ex1_def)
%apply(rule_tac x="{(x,y).\<exists> i\<in> (1 .. hwm). x = 
%names %^ i \<and> y = dates %^ i}" in exI)
%apply(rule_tac x="(rel_appl names) `
% (asSet(\<lambda>i. i : ( 1 .. hwm)))" in exI)
%apply(zunfold Abs_def BirthdayBook_def)
%apply(simp add: Z2HOL Ex1_def)
%apply(safe, simp_all)
%apply(simp only:pfun_def rel_def, auto intro!: lemma1)+
%apply(subst ZFun.beta_apply_pfun[of _ NAME DATE]) 
%prefer 3
%apply(rule refl)
%apply(auto)
%apply(rule pfunI)
%apply(simp add:rel_def)
%apply auto
%apply(auto intro!: lemma1)
%prefer 2
%apply(rule_tac t="dates %^ i" in subst)
%prefer 2
%apply(erule ZFun.rel_apply_in_rel,auto)
%apply(drule_tac x=aa in eqset_imp_iff,auto)
%apply(rule_tac x=x in bexI, auto)
%discharged
%po Fun_Refinement.fwRefinementInit_BirthdayBook_1
%apply zstrip
%apply(zunfold InitBirthdayBook1_def InitBirthdayBook_def 
%Abs_def BirthdayBook_def)
%apply(simp add: Z2HOL)
%discharged
%zlemma lemma3 : 
%"BirthdayBook1 \<and> (\<forall> i\<in>1\<upto>hwm. name?
% \<noteq> (names\<rappll>i\<rapplr>)) \<longrightarrow> pre AddBirthday1"
%apply(zstrip, zintro_pre AddBirthday1_def)
%apply(simp add: DECL_def DELTA_def, rule conjI)
%apply(rule_tac [2] conjI | rule_tac [2] refl)+ *}
%apply(zunfold BirthdayBook1_def)
%apply(simp add: Ball_def maplet_def zpred_def, auto)
%apply(rotate_tac 1)
%apply(case_tac [1] "x=(hwm+1)")
%apply(case_tac [1] "xa=(hwm+1)")
%apply(case_tac [3] "xa=(hwm+1)")
%apply(auto simp: zpred_def)
%done
%zlemma lemma4 : "pre AddBirthday \<longrightarrow> name? 
%\<notin> known"
%by(zstrip,zelim_pre,zunfold AddBirthday_def,auto)
%po Fun_Refinement.fwRefinementOp_AddBirthday_1 
%apply(zstrip, clarify)
%apply(zrule lemma3,zdrule lemma4,zdrule Abs_def[zpred [1]])
%apply(auto simp: Z2HOL)
%discharged
%lemma lemma6:
%"BirthdayBook (birthday, known) \<Longrightarrow>
% birthday : NAME \<pfun> DATE"
%by(zstrip, zunfold BirthdayBook_def,simp add: Z2HOL)
%lemma lemma7:
%"\<lbrakk> BirthdayBook (birthday, {a. \<exists>i\<in>1
% \<upto> hwm. names\<rappll>i\<rapplr> = a});
%    BirthdayBook (birthday'a, {a. \<exists>i\<in>1 \<upto>
%     hwm'. names'\<rappll>i\<rapplr> = a});
%    BirthdayBook1 (dates, hwm, names); BirthdayBook1 
%    (dates', hwm', names');
%    AddBirthday1 (dateI, dates, dates', hwm, hwm', nameI,
%     names, names');
%    BirthdayBook (birthday', known');
%    \<forall>i\<in>1 \<upto> hwm. names\<rappll>i\<rapplr> 
%     \<noteq>  nameI;
%    birthday' = insert (nameI, dateI) birthday;
%    \<forall>i\<in>1 \<upto> hwm. birthday %^ 
%    (names\<rappll>i\<rapplr>) = dates\<rappll>i\<rapplr>;
%    \<forall>i\<in>1 \<upto> hwm'. birthday'a %^
%     (names'\<rappll>i\<rapplr>) = dates'\<rappll>i\<rapplr> \<rbrakk>
%  \<Longrightarrow> \<dom> birthday'a = insert nameI
%   (\<dom> birthday)"
%apply(subgoal_tac "nameI ~: dom birthday")
%apply(simp add: insert_is_pfun)
%apply(zunfold BirthdayBook_def,simp add: Z2HOL)
%apply((erule conjE)+, drule sym, simp) 
%apply(zunfold AddBirthday1_def BirthdayBook1_def,
%simp add: maplet_def Z2HOL,clarify)
%defer 1
%apply(zunfold BirthdayBook_def,simp add: maplet_def Z2HOL,clarify)
%apply(drule_tac t="dom ?Z" in sym)+
%apply(simp,blast)
%apply(thin_tac "?X")
%apply(drule_tac t="dom ?Z" in sym)+
%apply(rule set_ext, simp,safe,simp)
%apply(case_tac "i=hwm+1",simp)
%apply(rotate_tac -2)
%apply(erule_tac x=i in ballE,simp)
%apply(simp add: zpred_def) 
%apply(rule_tac x="hwm+1" in bexI,simp, simp, 
%      simp add: numb_range_def in_naturals[symmetric])
%apply(rule_tac x=i in bexI)
%apply(thin_tac "ALL x:?S. ?P x")+
%apply(thin_tac "?T = ?U")+
%apply(subst oplus_by_pair_apply2, simp add: numb_range_def,simp)
%apply(simp add: numb_range_def)
%done
%lemma lemma8:
%"\<lbrakk> BirthdayBook (birthday, {a. \<exists>
%i\<in>1 \<upto> hwm. names %^ i = a});
%    BirthdayBook (birthday'a, {a. \<exists>
%    i\<in>1 \<upto> hwm. names' %^ i = a});
%    BirthdayBook1 (dates, hwm, names);
%     BirthdayBook1 (dates', hwm', names');
%    AddBirthday1 (dateI, dates, dates',
%     hwm, hwm', nameI, names, names');
%    BirthdayBook (birthday', known');
%    \<forall>i\<in>1 \<upto> hwm. names %^ i \<noteq>  nameI;
%    birthday' = insert (nameI, dateI) birthday;
%    \<forall>i\<in>1 \<upto> hwm. birthday %^
%     (names %^ i) = dates %^ i;
%    \<forall>i\<in>1 \<upto> hwm'. birthday'a %^
%     (names' %^ i) = dates' %^ i; 
%    i \<in> \<dom> birthday'a; \<dom> birthday'a =
%     \<dom> (insert (nameI, dateI) birthday) \<rbrakk>
% \<Longrightarrow> birthday'a\<rappll>i\<rapplr> =
%  insert (nameI, dateI) birthday\<rappll>i\<rapplr>"
%apply(subgoal_tac "nameI ~: dom birthday")
%apply(simp add: insert_is_pfun)
%apply(zunfold BirthdayBook_def,simp add: Z2HOL)
%apply((erule conjE)+, drule sym, simp) 
%apply(zunfold AddBirthday1_def,zunfold
% BirthdayBook1_def,simp add: maplet_def Z2HOL,clarify)
%defer 1
%apply(zunfold BirthdayBook_def,simp add: maplet_def Z2HOL,clarify)
%apply(drule_tac t="dom ?Z" in sym)+
%apply(simp,blast)
%apply(erule disjE, simp, (thin_tac "?T<:?S = ?U")+)
%apply(drule_tac x="nameI" in eqset_imp_iff) 
%apply(simp,safe, thin_tac "?X")
%apply(erule_tac x="hwm+1" and A="1..hwm +1" in ballE,simp)
%apply(simp add: numb_range_def in_naturals[symmetric])
%apply(thin_tac "?X", (thin_tac "?T \<dres>?S = ?U")+)
%apply(drule_tac x=i in eqset_imp_iff) back
%apply(simp, safe)
%apply(rule_tac A="1 .. hwm+1" and x = i in ballE)
%apply assumption 
%apply(subgoal_tac "((names \<oplus> {(hwm + 1, nameI)})
%\<rappll>i\<rapplr>) = names\<rappll>i\<rapplr>", simp)
%apply(subst oplus_by_pair_apply2)
%apply(simp add: numb_range_def in_naturals[symmetric])
%apply(rotate_tac 1)
%apply(erule_tac x=i in ballE,simp,simp)
%apply(subst oplus_by_pair_apply2)
%apply((thin_tac "ALL x:?S. ?P x")+, (thin_tac "?T = ?U")+,
%(thin_tac "?X : ?Y \<fun> ?Z")+,
%      simp add: numb_range_def in_naturals[symmetric], simp)
%apply((thin_tac "ALL x:?S. ?P x")+, (thin_tac "?T = ?U")+,
%(thin_tac "?X : ?Y \<fun> ?Z")+,
%      thin_tac "?X",thin_tac "?X",thin_tac "?X",thin_tac 
%      "?X", thin_tac "?X")
%apply(simp add: numb_range_def in_naturals[symmetric])
%done
%po Fun_Refinement.fwRefinementOp_AddBirthday_2 
%apply(zstrip, clarify, zelim_pre)
%apply(zunfold Abs_def AddBirthday_def,
%      simp_all add: Z2HOL rel_appl_norm maplet_def,clarify)
%apply(rule pfun_ext)
%apply(erule lemma6)+
%apply(simp (no_asm)) 
%apply(rule_tac birthday'="insert (name?, date?) birthday"
% in lemma7,simp_all)
%apply(rule_tac birthday'a="birthday'a" and birthday'=
%"insert (name?, date?) birthday" 
%      in lemma8,simp_all)
%discharged
%check_po except ccOp ccState
%end
%txt{************ Rel_Refinement.thy ***********}
%
%theory  Rel_Refinement
%imports BBSpec
%begin
%set_abs "Abs"
%refine_init InitBirthdayBook InitBirthdayBook1
%refine_op   AddBirthday      AddBirthday1
%show_po Rel_Refinement.fwRefinementInit_BirthdayBook_1
%show_po Rel_Refinement.fwRefinementOp_AddBirthday_2
%list_po
%show_po BBSpec.ccOp_AddBirthday_1 
%        BBSpec.ccOp_AddBirthday1_1 
%        BBSpec.ccState_BirthdayBook_1 
%        BBSpec.ccState_BirthdayBook1_1 
%        Rel_Refinement.fwRefinementOp_AddBirthday_1 
%        Rel_Refinement.fwRefinementOp_AddBirthday_2 
%        Rel_Refinement.fwRefinementInit_BirthdayBook_1
%check_po except ccOp ccState fwRefinementFunctional 
%                fwRefinementOp fwRefinementInit
%po Rel_Refinement.fwRefinementInit_BirthdayBook_1
%apply zstrip
%apply(zunfold InitBirthdayBook1_def InitBirthdayBook_def
%               Abs_def BirthdayBook_def)
%apply(simp add: Z2HOL)
%discharged
%zlemma lemma1 : "pre AddBirthday \<longrightarrow> 
%name? \<notin> known"
%apply(zstrip)
%apply(zelim_pre)
%apply(zunfold AddBirthday_def)
%by(auto)
%zlemma lemma2 : 
%"BirthdayBook1 \<and> (\<forall> i\<in>1..hwm. name? 
%\<noteq> (names %^ i)) \<longrightarrow> pre AddBirthday1"
%apply(zstrip,zintro_pre AddBirthday1_def)
%apply(simp add: DECL_def DELTA_def, rule conjI)
%apply(rule_tac [2] conjI | rule_tac [2] refl)+
%apply(zunfold BirthdayBook1_def)
%apply(simp add: Ball_def maplet_def zpred_def, auto)
%apply(rotate_tac 1)
%apply(case_tac [1] "x=(hwm+1)")
%apply(case_tac [1] "xa=(hwm+1)")
%apply(case_tac [3] "xa=(hwm+1)")
%apply(auto simp: zpred_def)
%done
%po Rel_Refinement.fwRefinementOp_AddBirthday_1 
%apply(zstrip, clarify)
%apply(zrule lemma1,zdrule lemma2,zdrule Abs_def[zpred [1]])
%apply(auto simp: Z2HOL)
%discharged
%zlemma  lemma4:
%" (AddBirthday \<and> Abs \<and> AddBirthday1) \<longrightarrow> 
%   known` = {n. \<exists> i \<in> 1 .. hwm`. n = names` %^ i}"
%apply(zstrip, clarify)
%apply(simp add: set_simps prod_simps Z2HOL AddBirthday_def
% AddBirthday1_def Abs_def
%                BirthdayBook_def BirthdayBook1_def,clarify) 
%apply(simp add: Dom_Union image_def asSet_def maplet_def)
%apply(rule set_ext,simp,rule iffI)
%apply(erule disjE)
%apply(rule_tac x="hwm+1" in bexI) 
%apply(simp add: override_apply numb_range_mem in_naturals)
%apply(rule numb_range_mem)
%apply(simp_all add: in_naturals)
%apply(erule bexE)
%apply(rule_tac x=xa in bexI)
%apply(subst override_apply2) 
%apply(simp_all add: numb_range_def) 
%apply(erule exE)
%apply(case_tac "i=hwm+1", simp)
%apply(rule disjI2)
%apply(rule_tac x=i in exI)
%apply auto
%done
%zlemma lemma5 :
%" (AddBirthday \<and> Abs \<and> AddBirthday1) \<longrightarrow>  
%  (\<forall> i\<in>1 .. hwm`. birthday`%^(names`%^i) = dates`%^i)"
%apply(zstrip, clarify)
%apply(simp add: set_simps prod_simps Z2HOL AddBirthday_def
% AddBirthday1_def Abs_def
%                BirthdayBook_def BirthdayBook1_def,clarify) 
%apply(simp add: Dom_Union image_def asSet_def maplet_def)
%apply(case_tac "i=hwm+1",auto)
%apply(subst dom_insert_apply)
%apply(auto simp: zpred_def)
%done
%thm lemma5[zstrip]
%po Rel_Refinement.fwRefinementOp_AddBirthday_2 
%apply(zstrip, clarify)
%apply(zelim_pre, zintro_sch_ex)
%apply(rule_tac [2] refl)
%prefer 2 
%apply(subgoal_tac "BirthdayBook(birthday',known')")
%apply(rotate_tac 1, assumption)
%apply(zunfold AddBirthday_def)
%apply(tactic "full_expand_schema_tac [thm\"AddBirthday_def\"] 1") 
%     (* must remain during reminiscent simplifications *)
%apply(drule DECL_D1)
%apply(simp add: Z2HOL)
%apply simp
%apply(zunfold (0) Abs_def)
%apply(rule DECL_I, zunfold Abs_def AddBirthday_def)
%apply(drule DECL_D1) back
%apply(simp add: set_simps prod_simps Z2HOL)
%apply(rule conjI)
%apply(simp add: image_def asSet_def maplet_def)
%apply(zrule lemma4, auto)
%apply(zrule lemma5, auto)
%discharged
%check_po except ccOp ccState
%end
%
%\end{verbatim}
%
%\chapter{Full ZMathLang examples from start to finish.}
%
%\section{Vending Machine Example}
%\subsection{Vending Machine annotated}
%\label{app:vm_annotate}
%\begin{verbatim}
%\documentclass{article}
%\usepackage{zmathlang}
%\begin{document}
%
%\dratheory{T1}{0.5}{
%\begin{zed}
%\text{\declaration{\term{price}:\expression{\nat}}}
%\end{zed}
%
%\draschema{SS1}{
%\begin{schema}{VMSTATE}
%\text{\declaration{\term{stock}, \term{takings}: \expression{\nat}}}
%\end{schema}}
%
%\draschema{CS0}{
%\begin{schema}{VM\_operation}
%\text{\Delta VMSTATE} \\
%\text{\declaration{\term{cash\_tendered?},
% \term{cash\_refunded!}: \expression{\nat}}} \\
%\text{\declaration{\term{bars\_delivered!} : \expression{\nat}}}
%\end{schema}}
%
%\uses{CS0}{SS1}
%
%\draschema{PRE1}{
%\begin{schema}{exact\_cash}
%\text{\declaration{\term{cash\_tendered?}: \expression{\nat}}}
%\where
%\text{\expression{\term{cash\_tendered?} = \term{price}}}
%\end{schema}}
%
%\draschema{PRE2}{
%\begin{schema}{insufficient\_cash}
%\text{\declaration{\term{cash\_tendered?} : \expression{\nat}}}
%\where
%\text{\expression{\term{cash\_tendered?} < \term{price}}}
%\end{schema}}
%
%\draschema{PRE3}{
%\begin{schema}{some\_stock}
%\text{\declaration{\term{stock}: \expression{\nat}}}
%\where
%\text{\expression{\term{stock} > \term{0}}}
%\end{schema}}
%
%\draschema{CS1}{
%\begin{schema}{VM\_sale}
%\text{VM\_operation}
%\where
%\draline{PO1}{
%\text{\expression{\term{stock'} = 
%\term{\term{stock} - \term{1}}}} \\
%\text{\expression{\term{bars\_delivered!} = \term{1}}} \\
%\text{\expression{\term{cash\_refunded!} =
% term{\term{cash\_tendered?} - \term{price}}}} \\
%\text{\expression{\term{takings'} =
% \term{\term{takings} + \term{price}}}}}
%\end{schema}}
%
%\uses{CS1}{CS0}
%\requires{CS1}{PO1}
%
%\draschema{CS2}{
%\begin{schema}{VM\_nosale}
%\text{VM\_operation}
%\where
%\draline{PO2}{\text{\expression{\term{stock'} = \term{stock}}} \\
%\text{\expression{\term{bars\_delivered!} = \term{0}}} \\
%\text{\expression{\term{cash\_refunded!} = \term{cash\_tendered?}}}\\
%\text{\expression{\term{takings'} = \term{takings}}}}
%\end{schema}}
%
%\uses{CS2}{CS0}
%\requires{CS2}{PO2}
%
%\draschema{TS1}{
%\begin{zed}
%VM1 \defs \text{\expression{\text{exact\_cash}
% \land \text{some\_stock} \land \text{VM\_sale}}}
%\end{zed}}
%
%\uses{TS1}{PRE1}
%\uses{TS1}{PRE3}
%\uses{TS1}{CS1}
%
%\draschema{TS2}{
%\begin{zed}
%VM2 \defs \text{\expression{\text{insufficient\_cash}
% \land \text{VM\_nosale}}}
%\end{zed}}
%
%\uses{TS2}{PRE2}
%\uses{TS2}{CS2}
%
%\draschema{TS3}{
%\begin{zed}
%VM3 \defs \text{\expression{\text{VM1} \lor \text{VM2}}}
%\end{zed}}
%\totalises{TS3}{TS1}
%\totalises{TS3}{TS2}
%
%}
%
%\end{document}
%
%\end{verbatim}
%
%\subsection{Vending Machine full proof using \gls{zmath}}
%\label{app:vm_mathlang}
%
%\begin{verbatim}
%theory vm_fillin3
%imports 
%Main 
%
%begin 
%
%record VMSTATE = 
%STOCK :: nat
%TAKINGS :: nat
%
%locale zmathlang_vm =
%fixes price :: nat
%begin
%
%definition insufficient_cash :: 
% "nat  => bool"
%where 
%" insufficient_cash  cash_tendered == 
% cash_tendered < price  "
%
%definition exact_cash :: 
% "nat  => bool"
%where 
%"exact_cash cash_tendered  == cash_tendered = price"
%
%definition some_stock :: 
% "nat => bool"
%where 
%" some_stock stock == stock > 0 " 
%
%definition VM_operation :: 
%"VMSTATE => VMSTATE => nat => nat => nat => bool"
%where 
%" VM_operation vmstate vmstate' cash_tendered 
%cash_refunded bars_delivered == True"
%
%definition VM_nosale :: 
% "nat => nat => nat => nat => nat => nat => nat => bool"
%where 
%" VM_nosale stock takings stock' takings' cash_tendered
% cash_refunded bars_delivered ==
%((stock' = stock) 
%\<and> (bars_delivered = 0) 
%\<and> (cash_refunded = cash_tendered) 
%\<and> (takings' = takings))"
%
%definition VM_sale :: " nat => nat => nat => nat => 
%nat => nat => nat => bool"
%where 
%" VM_sale  stock takings stock' takings' cash_tendered
% cash_refunded bars_delivered ==
%(stock' = stock - 1) 
%\<and> (bars_delivered = 1) 
%\<and> (cash_refunded = cash_tendered - price) 
%\<and> (takings' = takings + price) "
%
%definition VM1 :: 
% "nat => nat  => nat => nat => nat => nat => nat => bool"
%where 
%" VM1  cash_tendered stock takings stock' takings'
% cash_refunded bars_delivered ==
%(exact_cash cash_tendered )
% \<and> (some_stock stock )
% \<and> (VM_sale  stock takings stock' takings'
%  cash_tendered cash_refunded bars_delivered)"
%
%definition VM2 :: 
% "nat  => nat => nat => nat => nat => nat => nat => bool"
%where 
%" VM2  cash_tendered stock takings stock' takings'
% cash_refunded bars_delivered ==
%(insufficient_cash  cash_tendered)
% \<and> (VM_nosale stock takings stock' takings' 
% cash_tendered cash_refunded bars_delivered) "
%
%definition VM3 :: 
% "nat  => nat => nat => nat => nat => nat => nat => bool"
%where 
%" VM3  cash_tendered stock takings stock' takings' 
%cash_refunded bars_delivered = (
%(VM1  cash_tendered stock takings stock' takings' 
%cash_refunded bars_delivered)
% | (VM2  cash_tendered stock takings stock' takings'
%  cash_refunded bars_delivered)
%) "
%
%lemma pre_VM1: 
%"(\<exists> stock' takings' cash_refunded bars_delivered.
% VM1 cash_tendered stock takings stock' takings' 
% cash_refunded bars_delivered)
% \<Longleftrightarrow> (0 < stock) 
% \<and> (cash_tendered = price) \<and> (0 \<le> takings)"
%  apply (unfold VM1_def exact_cash_def some_stock_def VM_sale_def)
%  apply auto
%  done
%  
%  lemma pre_VM2: 
%"(\<exists> stock' takings' cash_refunded bars_delivered.
% VM2 cash_tendered stock takings stock' takings' 
% cash_refunded bars_delivered)
%  \<Longleftrightarrow> (cash_tendered < price) \<and>
%(cash_tendered \<ge> 0) \<and> (stock \<ge> 0) \<and> 
%(takings \<ge> 0)"
%apply (unfold VM2_def insufficient_cash_def VM_nosale_def )
%apply auto
%done
%
%  lemma pre_VM3: 
%"(\<exists> stock' takings' cash_refunded bars_delivered.
% VM3 cash_tendered stock takings stock' takings' 
% cash_refunded bars_delivered)
% \<Longleftrightarrow> (0 < stock \<and> cash_tendered =
% price \<and> 0 \<le> takings) \<or> (cash_tendered < price)
%\<and> (0 \<le> cash_tendered)
%\<and> (0 \<le> stock)
%\<and> (0 \<le> takings)"
%apply (unfold VM3_def VM2_def VM1_def some_stock_def 
%exact_cash_def VM_sale_def
%  VM_nosale_def insufficient_cash_def)
%apply auto
%done
%
%lemma cash_lemma: "\<not> (insufficient_cash cash_tendered 
%\<and> exact_cash cash_tendered)"
%apply (unfold insufficient_cash_def exact_cash_def)
%apply auto
%done
%
%lemma VM3_refines_VM1:
%"(\<exists> stock' takings' cash_refunded bars_delivered.
%((VM1 cash_tendered stock takings stock' takings' cash_refunded
%bars_delivered)
%\<rightarrow>
%(VM3 cash_tendered stock takings stock' takings' cash_refunded
%bars_delivered))
%\<and>
%(((VM1 cash_tendered stock takings stock' takings' cash_refunded
%bars_delivered)
%\<and>
%(VM3 cash_tendered stock takings stock' takings' cash_refunded
%bars_delivered))
%\<rightarrow>
%(VM1 cash_tendered stock takings stock' takings' cash_refunded
%bars_delivered)))"
%apply (unfold VM3_def VM1_def VM_sale_def exact_cash_def 
%some_stock_def)
%apply auto
%done
%
%lemma VM3_ok:
%"(\<exists> stock' takings cash_refunded bars_delivered.
%(VM3 cash_tendered stock takings stock' takings' cash_refunded
%bars_delivered)
%\<rightarrow>
%((takings' - takings) \<ge> price * (stock - stock' )))"
%apply (unfold VM3_def VM1_def VM2_def exact_cash_def 
%some_stock_def
%  VM_sale_def VM_nosale_def insufficient_cash_def)
%apply auto
%done
%
%end
%end
%\end{verbatim}
%
%\section{Birthday Book Example}
%
%\subsection{Birthday Book annotated}
%\label{app:bb_annotate}
%
%\begin{verbatim}
%\documentclass{article}
%\usepackage{zmathlang}
%
%\begin{document}
%
%\dratheory{T1}{0.34}{
%
%\begin{zed}
%[\set{NAME}] 
%\end{zed}
%
%\begin{zed}
%[\set{DATE}]
%\end{zed}
%
%\draschema{SS1}{
%\begin{schema}{BirthdayBook}
%    \text{\declaration{\set{known}: \expression{\power NAME}}} \\
%    \text{\declaration{\set{birthday}: \expression{NAME \pfun DATE}}}
%\where
%    \draline{SI1}{\text{\expression{\set{known}=\set{\dom \set{birthday}}}}}
%\end{schema}}
%
%\requires{SS1}{SI1}
%
%\draschema{IS1}{
%\begin{schema}{InitBirthdayBook}
%    \text{BirthdayBook}
%\where
%    \draline{PO2}{\text{\expression{\set{known'} = \set{\{ \}}}}}
%\end{schema}}
%
%\requires{IS1}{PO2}
%
%\initialof{IS1}{SS1}
%
%\draschema{CS1}{
%\begin{schema}{AddBirthday}
%\text{\Delta BirthdayBook} \\
%\text{\declaration{\term{name?}: \expression{NAME}}} \\
%\text{\declaration{\term{date?}: \expression{DATE}}}
%\where
%\draline{PRE1}{\text{\expression{\term{name?} \notin \set{known}}}}\\
%\draline{PO3}{\expression{\set{birthday'} = 
%\set{\set{birthday} \cup \set{\{\term{\term{name?} \mapsto \term{date?}}\}}}}}
%\end{schema}}
%
%\uses{CS1}{IS1}
%\requires{CS1}{PRE1}
%\allows{PRE1}{PO3}
%
%\draschema{OS1}{
%\begin{schema}{FindBirthday}
%    \text{\Xi BirthdayBook} \\
%    \text{\declaration{\term{name?}: \expression{NAME}}} \\
%    \text{\declaration{\term{date!}: \expression{DATE}}}
%\where
%    \draline{PRE2}{\text{\expression{\term{name?} 
%    \in \set{known}}}}\\
%    \draline{O1}{\text{\expression{\term{date!} =
%     \term{\set{birthday}~(\term{name?})}}}}
%\end{schema}}
%
%
%\allows{PRE2}{O1}
%\uses{OS1}{SS1}
%\requires{OS1}{PRE2}
%
%
%\begin{zed} 
%    \set{REPORT} ::= \term{ok} | \term{already\_known} | 
%    \term{not\_known}
%\end{zed}
%
%\draschema{OS3}{
%\begin{schema}{Success}
%    \text{\declaration{\term{result!}: \expression{REPORT}}}
%\where
%    \draline{O3}{\text{\expression{\term{result!} = \term{ok}}}}
%\end{schema}}
%
%\requires{OS3}{O3}
%\uses{OS3}{SS1}
%
%\draschema{OS4}{
%\begin{schema}{AlreadyKnown}
%    \text{\Xi BirthdayBook} \\
%    \text{\declaration{\term{name?}: \expression{NAME}}} \\
%    \text{\declaration{\term{result!}: \expression{REPORT}}}
%\where
%    \draline{PRE3}{\text{\expression{\term{name?}
%     \in \set{known}}}} \\
%    \draline{O4}{\text{\expression{\term{result!}
%     = \term{already\_known}}}}
%\end{schema}}
%
%\requires{OS4}{PRE3}
%\allows{PRE3}{O4}
%\uses{OS4}{SS1}
%
%\draschema{OS5}{
%\begin{schema}{NotKnown}
%    \text{\Xi BirthdayBook} \\
%    \text{\declaration{\term{name?}: \expression{NAME}}} \\
%    \text{\declaration{\term{result!}: \expression{REPORT}}}
%\where
%    \draline{PRE4}{\text{\expression{\term{name?}
%     \notin \set{known}}}} \\
%    \draline{O5}{\text{\expression{\term{result!}
%     = \term{not\_known}}}}
%\end{schema}}
%
%\requires{OS5}{PRE4}
%\allows{PRE4}{O5}
%\uses{OS5}{SS1}
%
%\begin{zed} 
%    \draschema{TS1}{RAddBirthday ==
%     \text{\expression{(\text{AddBirthday} \land
%      \text{Success})\\  \lor \text{AlreadyKnown}}}} \\
%    \draschema{TS2}{RFindBirthday == 
%    \text{\expression{(\text{FindBirthday} \land 
%    \text{Success}) \lor \text{NotKnown}}}} 
%\end{zed}
%
%\totalises{TS1}{CS1}
%\totalises{TS1}{OS3}
%\totalises{TS1}{OS4}
%\totalises{TS2}{OS1}
%\totalises{TS2}{OS3}
%\totalises{TS2}{OS5}
%
%}
%\end{document}
%\end{verbatim}
%
%\subsection{Birthday Book full proof using \gls{zmath}}
%\label{app:bb_fullproof}
%
%\begin{verbatim}
%theory bb
%
%imports 
%
%Main
%
%begin 
%
%typedecl NAME
%typedecl DATE
%
%datatype  REPORT = ok | already_known | not_known
%
%record BirthdayBook = 
%KNOWN :: " NAME set"
%BIRTHDAY :: "(NAME * DATE) set"
%
%locale zmathlang_birthdaybook = 
%fixes known :: " NAME set"
%and birthday :: "(NAME * DATE) set"
%assumes "known = Domain birthday"
%
%begin
%
%definition InitBirthdayBook :: 
% " BirthdayBook \<Rightarrow> NAME set => (NAME * DATE) set => bool"
%where 
%"InitBirthdayBook birthdaybook known' birthday' ==  (
%(known' = {})
%\<and> (birthday' = {})
%\<and> (known' = Domain birthday')
%) 
%"
%
%definition FindBirthday :: 
% "BirthdayBook => BirthdayBook => NAME => DATE => bool"
%where 
%"FindBirthday birthdaybook birthdaybook' name date == ((
%(name \<in> known)))
%\<and> (
%((name, date) \<in> birthday ))"
%
%definition NotKnown :: 
% "BirthdayBook => BirthdayBook => NAME => REPORT => bool"
%where 
%"NotKnown birthdaybook birthdaybook' name result == ((
%(name \<notin> known)))
%\<and> ((
%(result = not_known)))"
%
%definition AlreadyKnown :: 
% "BirthdayBook => BirthdayBook => NAME => REPORT => bool"
%where 
%"AlreadyKnown birthdaybook birthdaybook' name result == ((
%(name \<in> known)))
%\<and> ((
%(result = already_known)))"
%
%definition AddBirthday :: 
%"BirthdayBook => BirthdayBook =>  NAME set =>
% (NAME * DATE) set => NAME => DATE => bool"
%where 
%"AddBirthday birthdaybook birthdaybook'
% known' birthday' name date ==
%(
%(name \<notin> known)
%\<and> 
%(birthday' = birthday \<union> {(name, date)})
%)"
%
%definition Success :: 
% "REPORT => bool"
%where 
%"Success result == ((
%(result = ok)))"
%
%definition RFindBirthday :: 
% "BirthdayBook => BirthdayBook => NAME =>
%  DATE => REPORT => bool"
%where 
%"RFindBirthday birthdaybook birthdaybook'
% name date result = (
%((FindBirthday birthdaybook birthdaybook'
% name date) &
% (Success result)) |
% (NotKnown birthdaybook birthdaybook' name result) ) "
% 
%definition RAddBirthday :: 
% "BirthdayBook => BirthdayBook =>  NAME set => (NAME * DATE) set
%  => NAME => DATE => REPORT => bool"
%where 
%"RAddBirthday birthdaybook birthdaybook' known' birthday' 
%name date result = (
%((AddBirthday birthdaybook birthdaybook' known' birthday'
% name date) &
% (Success result))  |
% (AlreadyKnown birthdaybook birthdaybook' name result) ) "
% 
%definition (in zmathlang_birthdaybook)
%birthdaybookstate :: "BirthdayBook \<Rightarrow> bool"
%where
%"birthdaybookstate birthdaybook == (known = Domain birthday)"
%
%lemma AddBirthdayIsHonest:
%"(\<exists> known' birthday' birthdaybook birthdaybook' date.
%AddBirthday birthdaybook birthdaybook' known' birthday' name date)
%\<longleftrightarrow>
%(name \<notin> known)"
%apply (unfold AddBirthday_def)
%apply auto
%done
%
%lemma preAddBirthdayTotal:
%" (name \<notin> known) \<or> (name \<in> known)"
%apply (rule excluded_middle)
%done
%
%lemma BirthdayBookPredicate:
%"(\<exists> birthdaybook. birthdaybookstate birthdaybook)
% \<longrightarrow> known = Domain birthday"
%apply (rule impI)
%apply (unfold birthdaybookstate_def)
%apply auto
%done
%
%lemma InitIsOk:
%"(\<exists> birthdaybook. InitBirthdayBook birthdaybook known' birthday' 
%\<longleftrightarrow> (known' = {}) \<and> birthday'= {})"
%apply (unfold InitBirthdayBook_def)
%apply auto
%done
%
%lemma knownAddBirthday:
%"( AddBirthday birthdaybook birthdaybook' known'
% birthday' name date)
%  \<and> (InitBirthdayBook birthdaybook known' birthday')
%\<longrightarrow> known' = known \<union> {(name)}"
%apply (unfold AddBirthday_def)
%apply (unfold InitBirthdayBook_def)
%apply (rule impI)
%apply auto
%done
%
%lemma RAddBirthdayIsTotal:
%"(\<exists> known' birthday' birthdaybook birthdaybook' date.
%RAddBirthday birthdaybook birthdaybook' known' birthday' name date result)
%\<longrightarrow>
%(name \<notin> known) \<or> (name \<in> known)"
%apply (unfold RAddBirthday_def)
%apply (unfold AddBirthday_def AlreadyKnown_def Success_def)
%apply auto
%done
%
%end
%end
%\end{verbatim}
%
