\chapter{Z Document Rhetorical aspect}
\label{ch:zdra}
The \gls{zdra} is similar to the \gls{dra} for mathematics in MathLang. Here we describe how
the \gls{zdra} was designed an implemented. 

We use the ZMathLang \LaTeX{} package to chunk specifications together and see
the relationships between them. The mathematical instances used are
\textit{theory} and \textit{axiom}, which are used in theorem prover syntax. We
also use \textit{precondition}, \textit{postcondition}, \textit{output},
\textit{stateInvariants}, \textit{stateschema}, \textit{outputschema},
\textit{changeschema} and \textit{totaliseSchema}.

We created the ZDRa for the following:

\begin{itemize}

\item Identifying loops in the reasoning of specifications.
\item Checking the specification is robust by making sure schemas have been
totalised.
\item Identifying the relationships between chunks of specification.
\item Making sure state invariants do not change throughout the specification.
\item Creating a dependency graph to create a formal proof sketch from the ZDRa.
\end{itemize}

As well as having instances, the ZDRa shows relations between them to make sure
there are no loops in reasoning and to give warning in some situations (e.g.
specification is not totalised).

We have chosen to identify loops in the reasoning as it determines whether the
program is deterministic. Safety-critical systems must be deterministic,
practices which can lead to non-determinism must be avoided or carefully
controlled \cite{rierson2013developing}. Identifying loops in the reasoning is
one of these practices. Checking for loops in the reasoning can also be
automatically checked on an informal specification as shown in section \ref{sec:zdrainformal}.

There are millions of safety properties one can check for however we have chosen
to check the state invariants \& checking the robustness of the specification as
these will be the easiest to automate using the information we have from the
annotations.

It is important to have a robust and totalised specification (in particular one
for a high integrity system) because totalisation leaves less room for error.
Specifications which are totalised are complete and therefore system
requirements are better understood and the programmer would have
less assumptions about the system.
By totalising schemas all preconditions will have a corresponding postcondition.
Therefore when executing the system if all possible preconditions have a
corresponding output (post condition) then the computing system will be able to
handle errors better. Building a robust system encompasses as many points of
failure  as possible and one way to do this is to make the specification total.

Identifying relationships between chunks of specification is useful as it allows
us to carry out computations whether all dependencies are identified and to
check whether the relationships are sensible (for example all pre conditions
have a corresponding postconditions, a schema is defined if is used in another
schema). The relationships also allow users to explain the logical structure of
their system specification.

State invariants are conditions thats can be relied upon to be true during the
execution of the program. It is important that state invariants do not change as
they confirm your system specification is valid if the state invariants hold
even as the user states the preconditions and post conditions of each schema. 

The dependency graph is useful as it allows the user to identify which chunks of
specification are `\textit{dependent}' on each other i.e. if one chunk was
changed or removed then what other chunks would be affected. The dependency
graph also allow us to build the GoTo graph which orders the
specification to be automatically written in a theorem prover.

Section \ref{sec:zdra_annotate} describes the labels used to annotate a
specification. Then in section \ref{sec:zdra_implement} we illustrate the
implementations of the \gls{zdra} and how to check for rhetorical correctness.
The rhetorical errors which can be found are explained in sections
\ref{subsubsec:zdra_looperrors} and \ref{subsubsec:zdra_toterrors} and the
products which are created when a specification is rhetorically correct are
described in section \ref{subsec:zdra_prodcuts}.

\section{Annotations}
\label{sec:zdra_annotate}

In a similar way as  MathLang for mathematics \ref{sec:mathlangbackground}, we can label the specifications with
\gls{zdra} annotations (either before of after the \gls{zcga}) using our ZMathLang \LaTeX{} package . These
annotations chunks parts of the specification together and upon compiling shows
the relationships between each of these chunks.

We have chosen the following annotations for similar reasons as the \gls{zcga}.
We only wanted the minimum amount of categories in order to check for rhetorical
correctness. We also wanted the minimum amount of categories to translate the
specification into an Isabelle skeleton.

\begin{table}[H]
\begin{tabular}{| c | c | c | c |}
\hline
\textbf{Instance} & \textbf{Notation} & \textbf{\LaTeX{} Command}  \\
\hline
theory & T & $\backslash$dratheory\{\textit{T}\}\\
& & \{\textit{scaleoftheory}\}\{\textit{instance}\}  \\
\hline
stateschema & SS & $\backslash$draschema\{\textit{SS\#}\}\{\textit{instance}\}
\\
\hline
initialschema & IS & $\backslash$draschema\{\textit{IS\#}\}\{\textit{instance}\}
\\
\hline
changeschema & CS & $\backslash$draschema\{\textit{CS\#}\}\{\textit{instance}\}
\\
\hline
outputschema & OS & $\backslash$draschema\{\textit{OS\#}\}\{\textit{instance}\}
\\
\hline
totaliseschema & TS &
$\backslash$draschema\{\textit{TS\#}\}\{\textit{instance}\}  \\
\hline
axiom & A  & $\backslash$draschema\{\textit{A\#}\}\{\textit{instance}\}  \\
\hline
stateInvariants & SI & $\backslash$draline\{\textit{SI\#}\}\{\textit{instance}\}
\\
\hline
precondition & PRE & $\backslash$draline\{\textit{PRE\#}\}\{\textit{instance}\}
\\
\hline
postcondition & PO  & $\backslash$draline\{\textit{PO\#}\}\{\textit{instance}\}
\\
\hline
output & O  & $\backslash$draline\{\textit{O\#}\}\{\textit{instance}\}  \\
\hline
\end{tabular}
\caption{\label{tab:instances} \gls{zdra} instances with their notations and \LaTeX{} commands.}
\end{table}

\begin{table}[H]
\begin{tabular}{| c | c |}
\hline
\textbf{Relation} &  \textbf{\LaTeX{} Command} \\
\hline
initialOf &  $\backslash$initialof
\{\textit{instance\_1}\}\{\textit{instance\_2}\}  \\
\hline
uses & $\backslash$uses \{\textit{instance\_1}\}\{\textit{instance\_2}\}\\
\hline
requires & $\backslash$requires
\{\textit{instance\_1}\}\{\textit{instance\_2}\}\\
\hline
allows & $\backslash$allows \{\textit{instance\_1}\}\{\textit{instance\_2}\}\\
\hline
totalises & $\backslash$totalises
\{\textit{instance\_1}\}\{\textit{instance\_2}\}\\
\hline
\end{tabular}
\caption{\label{tab:relations} \gls{zdra} Relations with their notations and \LaTeX{} commands.}
\end{table}

Table \ref{tab:instances} shows the type of instance available in a Z
specification, the notation that goes along with it and the \LaTeX{} command the
user annotates that part of the specification with. It is important to name
instances as these names are what are referred to when creating the
relationships between them. Table \ref{tab:relations} shows the relationships
which are available between some of the instances. 

The instances described in table \ref{tab:instances} are the building blocks of
what makes a Z specification. These large chunks of specification are what were
common across the literature describing Z specifications including Ed Curries descriptions \cite{essenceofz} and Spiveys descriptions
\cite{spiveyreferencemanual} in one form or another. Just like in MathLang for
mathematics \ref{sec:mathlangbackground} which included instances such as Lemma,
Theorem, Proof, Definitions we can group chunk of text together to identify what
is a theory, stateschema, initschema, changeschema, outputschema,
totaliseschema, axiom, stateInvariants, precondition, postcondition and output.

\subsection{Instances}

We have designed the notation to include \verb|\draschema{..}{..}| for chunks of
specification which include schemas and \verb|\draline{..}{..}| which only
include lines within a schema.

If we combine together \emph{changeschema} and \emph{outputschema} then these
instances are the minimum amount of labels we need to create a compilable
Isabelle file as both \emph{changeschema} and \emph{outputschema} become
`\emph{definitions}' in Isabelle. However we have decided to label
\emph{changeschema} and \emph{outputschema} separately as the user can easily
identify which schemas can change the state of the system and which just output
particular results.

\subsubsection{theory}

A \emph{theory} would be a whole specification of one particular system.
Appendix \ref{app:bb2} shows an entire specification labelled in \gls{zdra}. You can have
more than one \emph{theory} in a single document. The \emph{theory} would
contain all other instances within it but no instance can have a \emph{theory}
inside of it.

\subsubsection{stateschema}

A \emph{stateschema} just like in Z is a single instance which outlines the
state of the system. Figure \ref{fig:exampleofss} shows an example of a
\emph{stateschema} instance. Note we have the label \verb|\draschema{SS1}{....}|
(shown in red) where we have labelled this \emph{stateschema} \verb|SS1|. There
may be one or more \emph{stateschema}'s in a theory. So users can label their
\emph{stateschema}'s accordingly, e.g.
\verb|SS1, SS2,SS3|.....\footnote{Although it is not needed for the user to annotate the
instances incrementally (the instances just need different names) we have used
it in our example to make it easier for the reader to identify how many of each instance is within the specification.}

\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
[+color[red]\draschema{SS1}{]\begin{schema}{BirthdayBook}known: \power NAME \\
birthday: NAME \pfun DATE \where[+color[blue]\draline{SI1}{]known=\dom
birthday[+color[blue]}]\end{schema}[+color[red]}]
\end{BVerbatim}
\end{footnotesize}
\caption{\label{fig:exampleofss} A stateschema and stateinvariants labelled in \gls{zdra}.}
\end{figure}

\emph{Stateschema's} are important to identify as they go in the premuable of the
Isabelle file.

\subsubsection{initialschema}

An \emph{initialschema} instance is optional within a \emph{theory}, there can
be more than one depending on how many \emph{stateschema}'s there are. Figure
\ref{fig:exampleofis} shows an example of an \emph{initialschema}. We use the
labelling \verb|\draschema{IS1}{...}| (shown in red) to denote the
\emph{initialschema}. We have named the \emph{initialschema} \verb|IS1| to show
it is the first initial schema in the \emph{theory}. If there was another
\emph{initialschema} we would name it \verb|IS2| and so on.

\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
[+color[red]\draschema{IS1}{]
\begin{schema}{InitBirthdayBook} 
BirthdayBook' 
\where 
[+color[blue]\draline{PO2}{]known' = \{ \}[+color[blue]}]
\end{schema} [+color[red]}]
\end{BVerbatim}
\caption{\label{fig:exampleofis} An initialschema labelled in \gls{zdra}.}
\end{footnotesize}
\end{figure}

\emph{Initschema's} are important to identify as they become \emph{definitions}
Isabelle file (if it exists as they are not always defined in specifications).

\subsubsection{changeschema}

A \emph{changeschema} instance is a schema/function which changes the current
state of the specification (these schemas are usually denoted by having a
\verb|\Delta| operator). There can be none or many \emph{changeschema} instances
within a theory.

\begin{center}
\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
[+color[red]\draschema{CS1}{]
\begin{schema}{AddBirthday}
\Delta BirthdayBook \\
name?: NAME \\
date?: DATE
\where
[+color[blue]\draline{PRE1}{]name? \notin known[+color[blue]}]
[+color[green]\draline{PO3}{]birthday' = birthday \cup \{name? \mapsto
date?\}[+color[green]}]
\end{schema} [+color[red]}]
\end{BVerbatim}
\end{footnotesize}
\caption{\label{fig:exampleofcs} A changeschema labelled in \gls{zdra}.}
\end{figure}
\end{center}

Figure \ref{fig:exampleofcs} shows an example of a \emph{changeschema} annotated
in \gls{zdra}. The schema is labelled with: \verb|\draschema{CS1}{...}| (shown
in red). We name this instance \verb|CS1| as it is the first \emph{changeschema}
instance seen in the specification, the next \emph{changeschema} should be named
\verb|CS2| then \verb|CS3| etc.

\emph{Changeschema's} are important to identify as they become \emph{definitions}
Isabelle file (if it exists as they are not always defined in specifications).

\subsubsection{outputschema}

An \emph{outputschema} instance is a schema or a function which does not change
the current state but only outputs information from the current state (these
schemas are usually denoted by having a \verb|\Xi| operator). Figure
\ref{fig:exampleofos} shows an example of an \emph{outputschema} instance in
\gls{zdra}. Note the line \verb|\draschema{OS4}{....| (shown in red) which names
the chunk \verb|OS4| that is the forth \emph{outputschema} in the specification.

\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
[+color[red]\draschema{OS4}{]
\begin{schema}{AlreadyKnown}
\Xi BirthdayBook \\
name?: NAME \\
result!: REPORT
\where
[+color[blue]\draline{PRE3}{]name? \in known[+color[blue]}] \\
[+color[green]\draline{O4}{]result! = already\_known[+color[green]}]
\end{schema} [+color[red]}]
\end{BVerbatim}
\end{footnotesize}
\caption{\label{fig:exampleofos} A outputschema labelled in \gls{zdra}.}
\end{figure}

\emph{Outputschema's} are important to identify as they become \emph{definitions}
Isabelle file (if it exists as they are not always defined in specifications).

\subsubsection{totaliseSchema}

\emph{Totaliseschema} instances are parts of the specification which totalise
preconditions within the specification. These are labelled as
\verb|TS#| where \verb|#| is some number. \emph{Totaliseschema} instances can written
in two ways. Either using the double equals operator:

\begin{verbatim}
\begin{zed}
A == B \land C
\end{zed}
\end{verbatim}

or by using the \verb|defs operator|:

\begin{verbatim}
\begin{zed}
A \defs B \land C
\end{zed}
\end{verbatim}

When labelling \emph{totaliseschema} instances the user can do this in two ways. The
first labelling is as a \verb|draschema| where the labelling comes before the
\verb|\begin{zed}| or as a \verb|draline| where the labelling wraps around the
line of the instance only. The second way is useful if there are more than one
\emph{totaliseschema} instance between the \verb|\begin{zed}| and \verb|\end{zed}|. 

\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
[+color[red]\draschema{TS3}{]
\begin{zed}
VM3 \defs VM1 \lor VM2 \end{zed}[+color[red]}]
\end{BVerbatim}
\end{footnotesize}
\caption{\label{fig:exampleofts1} A totalise schema instance labelled in \gls{zdra}.}
\end{figure}

An example of the \verb|draschema| labelling is shown in figure
\ref{fig:exampleofts1} where we have the label \verb|\draschema{TS3}{..| (shown
in red).

\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
\begin{zed} 
[+color[red]\draline{TS1}{]RAddBirthday == (AddBirthday \land Success)\\  \lor
AlreadyKnown[+color[red]}] \\
[+color[red]\draline{TS2}{]RFindBirthday == (FindBirthday \land Success) \lor
NotKnown[+color[red]}] \\
[+color[red]\draline{TS3}{]RRemind == Remind \land Success[+color[red]}]
\end{zed}
\end{BVerbatim}
\end{footnotesize}
\caption{\label{fig:exampleofts2} A totalise line instance labelled in \gls{zdra}.}
\end{figure}

An example of the \verb|draline| instance is shown in figure \ref{fig:exampleofts2}. In this example we have three \emph{totalise instances}
using the label \verb|\draline{TS1}{...|, \verb|\draline{TS2}{...| and
\verb|\draline{TS3}{...| respectfully (shown in red).

\emph{Totaliseschema} instances become the properties to prove when converted to the
half-baked proof (see chapter \ref{ch:skeletons} for details). This is because
totaliseschema instances will should contain a preconditions and postconditions
which should obey they stateinvariants within the specification. Totaliseschema
instances should be total and therefore complete. If all the totaliseschemas are
proved correct then their should be less room for errors within the entire
system.

\subsubsection{axiom}

\emph{Axiom} instances are knowns as axiomatic definitions in Z. There can be
more than one \emph{axiom} in a \emph{theory} or there can be none. An example
of an \emph{axiom} instance labelled in \gls{zdra} is shown in figure
\ref{fig:exampleofa}. Note the \gls{zdra} labelling consists if the line
\verb|\draschema{A1}{...| where the instance is named \verb|A1|.

\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
[+color[red]\draschema{A1}{]
\begin{axdef}
maxPlayers: \nat
\where
maxPlayers = 20 \end{axdef}[+color[red]}]
\end{BVerbatim}
\end{footnotesize}
\caption{\label{fig:exampleofa} A axiom instance labelled in \gls{zdra}.}
\end{figure}

\emph{Axioms} are important to identify as they go in the premuable of the
Isabelle file.

\subsubsection{stateInvariants}
The \emph{stateInvariants} instance are the conditions which must be obeyed
throughout the specifications. These are the lines founds inside the
\emph{stateschema} instance. Figure \ref{fig:exampleofss} shows a single
\emph{stateinvariant} instance labelled as \verb|\draline{SI1}{..| (shown in
blue). There can be 0 or more \emph{stateinvariance} instances within a
\emph{theory}. \emph{StateInvariants} are important to be identified in the ZDRa
as they come after the `\emph{assumes}' in the isabelle syntax (see chapter
\ref{chap:gpsa2isa} to see how stateinvariants are translated). Each definition
and lemma then described in Isabelle makes sure that all conditions obey the stateinvariants.

\subsubsection{precondition}

Similar to the \emph{totalise} instance, the \emph{precondition} instance can be
labelled as a \verb|draschema| or a \verb|draline|. An example of a
\emph{precondition} which is a line can be found in figures
\ref{fig:exampleofcs} and \ref{fig:exampleofos}. In figure \ref{fig:exampleofcs}
the \gls{dra} labelling for a \emph{precondition} schema is the line
\verb|\draline{PRE1}{..}| (shown in blue). The \emph{precondition} instance is
named \verb|PRE1| and \verb|name? \notin known| is the instance. In figure
\ref{fig:exampleofos} the \gls{zdra} labelling is 
\verb|\draline{PRE3}{..}|(shown in blue) where \verb|PRE3| is the name of the
instance and 
\verb|name?\in known| is the instance.

Another way a \emph{precondition} instance can exists is when an entire schema
only consist of \emph{precondition} instances and nothing else (no post
operations).

\begin{figure}[H]
\centering
\begin{footnotesize}
\begin{BVerbatim}[commandchars=+\[\]]
[+color[red]\draschema{PRE1}{]
\begin{schema}{exact\_cash}
cash\_tendered?: \nat
\where
cash\_tendered? = price \end{schema}[+color[red]}]
\end{BVerbatim}
\end{footnotesize}
\caption{\label{fig:exampleofpre} A precondition schema instance labelled in \gls{zdra}.}
\end{figure}

A \emph{precondition} instance which is an entire schema is shown in figure
\ref{fig:exampleofpre}. The \gls{zdra} labelling consists of the line
\verb|\draschema{PRE1}{..| where the name of the instance is \verb|PRE1|.

\emph{Precondition's} are important to identify as they must be checked that they
conform with the stateInvariants of the specification.

\subsubsection{postcondition}

The \emph{postcondition} instance can be labelled as a \gls{zdra} line. An
example of this is demonstrated in figure \ref{fig:exampleofcs} (shown in
green), where the name of the instance is \verb|PO3| and the instance itself is
\verb|birthday' = birthday \cup \{name? \mapsto date?\}|.

\emph{Postconditions's} are important to identify as they must be checked that they
conform with the stateInvariants of the specification.

\subsubsection{output}

An \emph{output} instance can also be labelled as a \gls{zdra} line. An example
of this is shown in green in figure \ref{fig:exampleofos}. The instance in this
case is named
 \verb|O4| and the instance itself is \verb|result! =already\_known|.

 \emph{Output's} are important to identify as they must be checked that they
conform with the stateInvariants of the specification.
\subsection{Relations}
\label{subsec:zdrarelations}

After labelling the instances within a relation the user may then add relations
between parts of the specification. The relationships available are
\emph{initialOf}, \emph{uses}, \emph{requires} and \emph{allows}.

\begin{table}[H]
\begin{tabular}{|lll||lll|}
\hline
\textbf{requires} & & &  & \textbf{uses} & \\
\hline
outputSchema & $\longrightarrow$ & precondition  & outputSchema &
$\longrightarrow$ & stateSchema\\
outputSchema & $\longrightarrow$ & output & changeSchema & $\longrightarrow$ &
stateSchema \\
changeSchema & $\longrightarrow$ & precondition  & stateSchema &
$\longrightarrow$ & stateSchema \\
changeSchema & $\longrightarrow$ & postcondition  & stateSchema &
$\longrightarrow$ & axiom \\
\cline{1-3}
\textbf{totalises} & &  & outputSchema & $\longrightarrow$ & axiom \\
\cline{1-3}
totaliseschema & $\longrightarrow$ & changeSchema  & changeSchema & $\longrightarrow$
& axiom \\
\cline{4-6}
totaliseschema & $\longrightarrow$ & outputSchema & \textbf{allows}  & & \\
\cline{4-6}
totaliseschema & $\longrightarrow$ & totaliseschema  & precondition  & $\longrightarrow$  &
postcondition \\
\cline{4-6}
totaliseschema & $\longrightarrow$ & precondition & \textbf{initialOf} &  &  \\ 
\cline{4-6}
& &  & initialSchema & $\longrightarrow$ & stateSchema \\ 
\hline
\end{tabular}
\caption{\label{tab:relationsallowed} The legal relations between instances. Where $\longrightarrow$ represents the relation.}
\end{table}

Table \ref{tab:relationsallowed} shows the legal relations between each of the
instances for example an \emph{initialSchema} can be an \emph{initialOf} a
\emph{stateSchema} but it wont allow say a \emph{changeSchema} to be
\emph{initialOf} an \emph{initialSchema} etc. These relations are all we need to
create a Dependency and GoTo graph and to describe the relationships between the
instances of the specification. These relations are also the minimum we need to
create the program to automatically translate the specification in the correct
order into an Isabelle file.

\subsubsection{initialOf}

An \emph{initialschema} instance can be an \emph{initialOf} a \emph{stateschema}
instance. An example of this would be \verb|\initialOf{IS1}{SS1}| where
\verb|IS1| is \emph{initialOf} \verb|SS1|.

\subsubsection{uses}
The \emph{uses} relation can be between \emph{changeSchema}'s,
\emph{outputSchema}'s, \emph{stateSchema}'s and \emph{totalise} instances. For
example, one can say that an \emph{outputSchema} \emph{uses} a
\emph{stateSchema}. To illustrate this the user can add the label
\verb|\uses{OS2}{SS1}|, meaning \emph{outputSchema} OS2, uses \emph{stateSchema}
SS1.

\subsubsection{requires}
The \emph{requires} relation is used between an \emph{outputSchema} or a
\emph{changeSchema} and a \emph{precondition}, \emph{output} or
\emph{postcondition}. If we take the example shown in figure
\ref{fig:exampleofis} we can say that the \emph{initialSchema} \verb|IS1|
\emph{requires} the postcondition \verb|PO2|. Therefore in \gls{zdra} notation
we would write in our \LaTeX{} specification \verb|\requires{IS1}{PO2}|.

\subsubsection{allows}
The \emph{allows} relation is used between \emph{precondition}'s and
\emph{postconditions} or \emph{preconditions} and \emph{outputs}. This relation
describes if an instance allows another instance to occur. That is an instance
can not exist unless pre-conditional requirements are met. An example of where
an \emph{allows} relationship would be useful is in figure
\ref{fig:exampleofos}, where we have a \emph{precondition} \verb|PRE3| (in blue)
and an \emph{output} \verb|O4| (in green). In this case the user would write in
their \gls{zdra} \LaTeX{} file: \verb|\allows{PRE3}{O4}|.

\subsubsection{totalises}
The \emph{totalise} relation allows users to describe which of their schema's
have been totalised. If there exists a precondition which has not been totalised
than the ZDRa check will identify this (see next section). Any schema which
contains \emph{preconditions} can be totalised in a \emph{totaliseschema}. For
example the the user can label \verb|\totalises{TS1}{PRE1}|


\section{Implementation}
\label{sec:zdra_implement}

The \gls{zdra} program automatically checks for rhetorical correctness of the
specification. To do this it reads the \gls{zdra} annotations created by the
user then if all is correct then the program automatically generates a
\emph{dependency graph} and a \emph{goto graph}. The input for the \gls{zdra}
program is the specification written in \LaTeX{} with the \gls{zdra}
annotations.

\subsection{Checking if a specification is correctly totalised}
\label{subsec:correctlytotalised}

The \gls{zdra} program uses regular expressions to read the annotations inputted
by the user to determine whether a specification has been totalised. For example
if we only have a single \emph{precondition} instance (PRE1), in a specification
and a single \emph{totalise} instance (TS1), in a specification and the user has
added the \emph{relation} \verb|totalises{TS1}{PRE1}|, then the specification
will be correctly totalised and there will be a message saying
"\texttt{Specification correctly totalised}". If there exists any preconditions
which the user hasn't annotated with a totalising relation then the \gls{zdra}
program will display a message saying "\texttt{Specification not correctly
totalised}". This message is a warning not an error therefore even if the
specification still has untotalised preconditions the user can still go on with
the next steps of computerisation.

It is important to have correctly totalised specifications, especially in safety
critical systems as it leaves less room for error when translating specification
into actual programs. If every preconditions have a corresponding postcondition
than the specification will be deemed `\emph{totalised}' and therefore a safer
system. With a totalised specification the programmer would not need to make any
assumptions and any defined state the system is in will have a corresponding
postcondition. Totalisation also adds a level of rigour to the specification for
example in the Sholis project \cite{sholis} described in chapter
\ref{ch:background} the Z specification found 75\% of faults in the system.
Without a totalised specification those faults would of been implemented in the
system and then potentially only found during testing where a lot of time and
money would of been spent.

\subsubsection{Errors}
\label{subsubsec:zdra_toterrors}

Table \ref{tab:totalisecorrect} shows examples of 3 specifications (named 1, 2
and 3). Specification 1 shows three \emph{preconditions} being annotated by the
user (PRE1, PRE2 and PRE3), all these preconditions have been annotated with the
relationship \emph{totalises}. Therefore if all preconditions in a schema have a
totalising condition then the specification is correctly totalised.
Specification 2 in the table shows 4 existing preconditions. All but one (PRE2)
precondition have a totalising relationship with a totalise schema. In this
case, PRE2 is an outstanding preconditions to be totalised and therefore the
message `\texttt{Specification incorrectly totalised} appears. Specification 3 in
table \ref{tab:totalisecorrect} shows 5 schema preconditions. When checking
totalising correctness it does not matter whether the preconditions are in
\verb|draline| form or \verb|draschema| form. In the third example we see that
PRE3 and PRE4 have not been totalised and again a message appears saying the
specification has not been correctly totalised.

\begin{table}[H]
\begin{tabular}{|c|c|c|c|}
\hline
& \textbf{Preconditions in} & \textbf{Totalises in} & \textbf{Outcome of} \\
& \textbf{specification} & \textbf{specification} & \textbf{\gls{zdra} program}
\\
\hline
\hline
& \verb|\draline{PRE1}| & \verb|\totalises{TS1}{PRE1}| & \\
1 & \verb|\draline{PRE2}| & \verb|\totalises{TS1}{PRE2}| & `\texttt{Spec
correctly} \\
& \verb|\draline{PRE3}| & \verb|\totalises{TS2}{PRE3}|& \texttt{totalised}'\\
\hline
& \verb|\draline{PRE1}| & \verb|\totalises{TS1}{PRE1}| &  \\
2 & \verb|\draline{PRE2}| & & \\
& \verb|\draline{PRE3}| & \verb|\totalises{TS2}{PRE3}|& `\texttt{Spec
incorrectly} \\
& \verb|\draline{PRE4}| & \verb|\totalises{TS3}{PRE4}|& \texttt{totalised}' \\
\hline
& \verb|\draschema{PRE1}| & \verb|\totalises{TS1}{PRE1}| &  \\
 & \verb|\draschema{PRE2}| & \verb|\totalises{TS2}{PRE2}| & \\
3 & \verb|\draschema{PRE3}| & & `\texttt{Spec incorrectly} \\
& \verb|\draschema{PRE4}| &  & \texttt{totalised}' \\
& \verb|\draschema{PRE5}| & \verb|\totalises{TS2}{PRE5}|  & \\
\hline
\end{tabular}
\caption{\label{tab:totalisecorrect} Examples of preconditions in a specification being correctly totalised and incorrectly totalised.}
\end{table}

\subsection{Checking if a specification has no loops in it's reasoning}
\label{subsec:loops}

The \gls{zdra} program also checks for rhetorical correctness, that is it checks
that there are no loops in the logical reasoning of the specification. To do
this the \gls{zdra} program imports a module named \texttt{networkX} to create a
\emph{directed graph}. The program also uses \emph{regular expressions} to read
the \gls{zdra} annotations and create nodes and edges. For example, if the
program finds \verb|\draline{x}{....}| or \verb|draline{y}{...}| then it will
add \texttt{x} and \texttt{y} as nodes to the directed graph. The edges are
created by reading the \emph{relations} in the \gls{zdra} annotated
specification. For example if the \gls{zdra} program finds \verb|\uses{x}{y}|
and \texttt{x} and \texttt{y} are nodes in the directed graph then it will add a
directed edge between \texttt{x} and \texttt{y} respectively. Nodes with no
edges at all can also be added to the graph.

Loops in the reasoning identify when two specifications or functions can call
one another (mutual recursion). This should be avoided when writing safety critical systems because
a system which has mutual recursion could possibly overload the stack and the
software will crash.

\subsubsection{Errors}
\label{subsubsec:zdra_looperrors}

The specification is correct when there are no loops in the created directed
graph. For example if there was a graph with edges [a$\rightarrow$b,
a$\rightarrow$c, b$\rightarrow$c] then that would still be legal as there are no
directed loops, however, if there was a graph with edges [a$\rightarrow$b,
b$\rightarrow$c, c$\rightarrow$a] then that would cause a loop in the reasoning
and the specification will not be \gls{zdra} correct. The program outputs a
message informing the user whether the specification is \gls{zdra} correct or
not.

\begin{figure}[H]
\vspace{-0.2in}
\centering
\begin{minipage}{0.45\textwidth}
\centering
\begin{scriptsize}
\begin{BVerbatim}
... \draschema{SS1}{
\begin{schema}{A}
C
\end{schema}}
\draschema{SS2}{
\begin{schema}{B}
A
\end{schema}}
\draschema{SS3}{
\begin{schema}{C}
B
\end{schema}}

\uses{SS1}{SS3}
\uses{SS2}{SS1}
\uses{SS3}{SS2}
...
\end{BVerbatim}
\end{scriptsize}
\vspace{-0.18in}
\caption{An example of a loop in the reasoning in a labelled ZDRa specification.\label{fig:aloop}}
\vspace{-0.2in}
\end{minipage}\hfill
\begin{minipage}{0.45\textwidth}
\centering
\includegraphics[scale=0.33]{Figures/zdra/zdraloop.png}
\vspace{-0.18in}
\caption{The pdflatex output of figure \ref{fig:aloop}.  \label{fig:zdraerror1}}
\vspace{-0.2in}
\end{minipage}
\end{figure}

Figure \ref{fig:zdraerror1} shows the relationship SS1 \textit{uses} SS3, SS2
\textit{uses} SS1 and SS3 \textit{uses} SS2. The ZDRa would not allow this as
the reasoning would be in a loop and would not be correct. When running the
\gls{zdra} check on this specification the message which would appear is shown
in figure \ref{fig:zdraerrormess}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{Figures/zdra/loopmessage.png}
\caption{An example of an error message when a specification is not \gls{zdra} correct. \label{fig:zdraerrormess}}
\end{figure}

If the specification is \gls{zdra} correct then the program also creates visual
dependency and GoTo graphs automatically (see section
\ref{subsec:zdra_prodcuts}). If not then the graphs are not created.

A specification which passes \gls{zcga} but not \gls{zdra} is shown in appendix
\ref{app:failzdra}. There is one loop in the reasoning of this specification and
the user is able to see it when they annotated the specification in \gls{zdra}
and have compiled the document using \texttt{pdflatex}. A snippet of this is
shown in figure \ref{fig:zdraloopsnippet} and the full version is shown in
appendix \ref{app:failzdraout}.

\begin{figure}[H]
\includegraphics[clip, trim=0cm 10cm 6cm 11cm, scale=1.3]{examples/nonworkzdra/1n2.pdf}
\caption{A snippet from appendix \ref{app:failzdra} showing a loop in reasoning. \label{fig:zdraloopsnippet}}
\end{figure}

When the specification is checked with \gls{zcga} then the output message says
the specification is grammatically correct. However when the specification is
checked with \gls{zdra}, the message says that circular reasoning has been found
and shows the path of the loop, which in this case is \verb|CS4, TS4, TS5, TS6|.
The error message which appears specifically for this example in shown in figure
\ref{app:failzdraoutmessgae} in appendix \ref{app:failzdraoutmes}.

\subsection{ZDRa Outputs}
\label{subsec:zdra_prodcuts}

When the specification has been ZDRa checked the program will then output two
new files. 

\begin{enumerate}

\item ZDRa specification Dependency Graph

\item ZDRa specification GoTo Graph
\end{enumerate}

The \gls{zdra} specification Dependency graph uses the labels and annotations
from the \gls{zdra} to show the dependencies between each of the instances. The
ZDRa GoTo graph illustrates which instances are dependent or are needed for
another instance to exist. Both graphs are directed graph built
within the \gls{zdra} check (see section \ref{subsec:loops}). Further information on
how these products are formed can be found in the next chapter.

\subsubsection{Dependency Graph}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{Figures/zdra/depgraph.png}
\caption{An example of a dependency graph. \label{fig:depgraph}}
\end{figure}

An example of a \emph{dependency graph} can be seen in figure
\ref{fig:depgraph}. This image represents the compiled \gls{zdra} annotated
document in graph form. All the boxes that show up in the compiled document
are represented by nodes in the graph. The arrows from the instances are
represented by the edges in the graph, all the arrows in the document and edges
in the graph should be pointing in the same direction.

The dependency graph is a directed graph representing the dependencies
of instances. The benefits of a dependency graph would be for system analysis, one can see
which parts of the specification are \textbf{dependent} on others. For example
if one were to change a function (schema) which other functions would be
affected. Circular reasoning will also be easy to identify on a dependency graph.


\subsubsection{GoTo Graph}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{Figures/zdra/gotograph.png}
\caption{An example of a goto graph \gls{zdra} correct. \label{fig:gotograph}}
\end{figure}

An example of a \emph{goto graph} is shown in figure \ref{fig:gotograph}, it is
very similar to the \emph{dependency graph}. The \emph{goto graph} also uses the
boxes created by the \gls{zdra} annotations \verb|draschema| and \verb|draline|.
However the only slight difference is the directions the edges are pointing to
in some of the relations. For example if we had the relation
\verb|\initialOf{IS1}{SS1}|, in the compiled document and in the
\emph{dependency graph} the arrow will be going from \verb|IS1| to \verb|SS1|
this is because it is indeed true that the initial schema \verb|IS1| is the
\textbf{initial of} the state schema \verb|SS1|. On the other hand, in the
\emph{goto graph} the edge is pointing the other way from the stateschema
\verb|SS1| to the initialschema \verb|IS1|. This is because the initialschema
\verb|IS1| needs \verb|SS1| to exist, that is if \verb|SS1| didn't exist then
\verb|IS1| couldn't initialize it. Therefore the instance \verb|IS1| is dependent
on \verb|SS1|.

The other \gls{zdra} relations which also reverse the direction of the arrow in
the \emph{goto graph} are \emph{uses}, \emph{requires} and \emph{totalises}.

The GoTo graph represents the order the instances should go in when translating
the specification into Isabelle syntax.

The dependency and GoTo graphs contain the same instances and the same
relations, however  the direction of the relations may be different. These differences between the dependency and GoTo graphs are
described in the next chapter.

\section{ZDRa on an Informal Specification}
\label{sec:zdrainformal}

One of the main benefits is that the \gls{zdra} checker can be used on
specifications which are written entirely in natural language. This is
particularly useful if the specification has been written by multiple people.

For example the specification below shows a list of requirements.

\noindent\fbox{%
    \parbox{\textwidth}{%
    \begin{enumerate}
    \item The Unmanned Air Vehicle takes command from the Wildcat Helicopter.
    \item The Unmanned Air Vehicle shall stay in it's allocated airspace.
    \item The Wildcat Helicopter takes command from the Chinook.
    \item The Wildcat Helicopter shall stay on base until told to deploy.
    \item The Chinook takes command from the Unmanned Air Vehicle.
    \end{enumerate}
    }
}

The user can then annotated these informal requirements in \gls{zdra}. This is
shown in figure \ref{fig:informalzdraexample} where the \gls{zdra} commands are in {\color{blue}blue}.

\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tiny}
    \begin{BVerbatim}[commandchars=+\[\]]
\documentclass{article}
\usepackage{zmathlang}
\begin{document}
[+color[blue]\dratheory{T5}{0.3}{        ]
[+color[blue]\draschema{CS1}{]The Unmanned Air Vehicle takes command from the
Wildcat Helicopter.[+color[blue]}]
[+color[blue]\draschema{CS2}{]The Unmanned Air Vehicle shall stay in it's
allocated airspace.[+color[blue]}]
[+color[blue]\draschema{CS3}{]The Wildcat Helicopter takes command from the 
Chinook.[+color[blue]}]
[+color[blue]\draschema{CS4}{]The Wildcat Helicopter shall stay on base until
told to deploy.[+color[blue]}]
[+color[blue]\draschema{CS5}{]The Chinook takes command from the Unmanned Air Vehicle.[+color[blue]}]
           
[+color[blue]\uses{CS1}{CS5}]
[+color[blue]\uses{CS5}{CS3}]
[+color[blue]\uses{CS3}{CS1}}]
\end{document}      
    \end{BVerbatim}
    \end{tiny}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{Figures/fullexample/zdrainformalexample.png}
    \end{minipage}
    \caption{Informal requirements example \gls{zdra}.\label{fig:informalzdraexample}}
    \end{figure}

The ZMathLang toolkit will identify the circular reasoning and tell the
user(requirements 1, 3 and 5). 
It will also produce the following graph to show that the 3 requirements are
dependent on each other and therefore show there is an error. This loop is shown
in figure \ref{fig:informalloop}.

\begin{figure}[H]
    \includegraphics[width=12cm]{informal/dep.png}
    \caption{Dependency graph of the loop in the informal specification example detailed in figure \ref{fig:informalzdraexample}. \label{fig:informalloop}}
\end{figure}


\section{Conclusion}
In this chapter the \gls{zdra} step of the \gls{zmath} has been described. A
\LaTeX{} style package has been created to allow a user to annotate a Z
specification and see the structure of the system. A \gls{zdra} program has been
created to check for rhetorical correctness and make sure there are no loops in
the reasoning of the specification. Warning messages appear if the specification
is still lacking some totalising schemas for some preconditions. We have also
formally outlined the \gls{zdra} and shown some rules which occur when combining
the \gls{zcga} and \gls{zdra} together. If the specification is correct at the
\gls{zdra} stage then the user may then go on to create general and theorem
prover specific skeletons which are described in the next chapter.